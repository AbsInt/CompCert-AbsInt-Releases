(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Bernhard Schommer, AbsInt Angewandte Informatik GmbH       *)
(*                                                                     *)
(*  AbsInt Angewandte Informatik GmbH. All rights reserved. This file  *)
(*  is distributed under the terms of the INRIA Non-Commercial         *)
(*  License Agreement.                                                 *)
(*                                                                     *)
(* *********************************************************************)


(** Translation from Mach to PEAKTOP assembly language *)

Require Archi.
Require Import Coqlib Errors.
Require Import AST Integers Floats Memdata.
Require Import Op Locations Mach Asm.

Local Open Scope string_scope.
Local Open Scope error_monad_scope.

(** The code generation functions take advantage of several
  characteristics of the [Mach] code generated by earlier passes of the
  compiler, mostly that argument and result registers are of the correct
  types.  These properties are true by construction, but it's easier to
  recheck them during code generation and fail if they do not hold. *)

(** Extracting integer or float registers. *)

Definition reg_of (r: mreg) : res reg :=
  match preg_of r with GPR mr => OK mr | _ => Error(msg "Asmgen.reg_of") end.

Definition ireg_of (r: mreg) : res reg :=
  match preg_of r with GPR mr => OK mr | _ => Error(msg "Asmgen.ireg_of") end.

Definition freg_of (r: mreg) : res reg :=
  match preg_of r with GPR mr => OK mr | _ => Error(msg "Asmgen.freg_of") end.


(** Decomposition of integer constants. There are three different sizes for
  immediate constants, 12-bit, 14-bit and 18-bit which are used for the different
  instructions and are interpreted after zero extension or sign extension. Integer
  constants that do not fit must be synthesized by several processor instructions.
  The following functions decompose arbitrary 32-bit integers into their two parts.
  They satisfy the following properties:
- [low_u_14 n] is an unsigned 14-bit integer;
- [low_s_k n] is a signed k-bit integer;
- [(high_u_k 18) << 14 | low_u_14 n] equals [n];
- [(high_s_k n) << (32 - k) + low_s_(32-k) n] equals [n];
*)

Definition low_u_14 (n: int) := Int.and n (Int.repr 16383).
Definition high_u_18 (n: int) := Int.shru n (Int.repr 14).
Definition low_s_12 (n: int) := Int.sign_ext 12 n.
Definition high_s_20 (n: int) := Int.shru (Int.sub n (low_s_12 n)) (Int.repr 12).
Definition low_s_18 (n: int) := Int.sign_ext 18 n.
Definition high_s_14 (n: int) := Int.shru (Int.sub n (low_s_18 n)) (Int.repr 18).
Definition low_s_14 (n: int) := Int.sign_ext 14 n.
Definition high_s_18 (n: int) := Int.shru (Int.sub n (low_s_14 n)) (Int.repr 14).

(** Smart constructors for arithmetic operations involving
  a 32-bit integer constant.  Depending on whether the
  constant fits in 18 bits or not, one or several instructions
  are generated as required to perform the operation
  and prepended to the given instruction sequence [k]. *)

Definition loadimm (r: reg) (n: int) (k: code) :=
  if Int.eq (high_s_14 n) Int.zero then
    Pmov_ri r n :: k
  else if Int.eq (low_s_18 n) Int.zero then
    Pmov_ri r (high_s_14 n) ::
    Pslil r (Int.repr 18) :: k
  else
    Pmovu_ri r (high_u_18 n) ::
    Pslil r (Int.repr 14) ::
    Porui r (low_u_14 n) :: k.

Definition opimm (insn2: reg -> reg -> instruction)
                 (insn1: reg -> int -> instruction)
                 (r: reg) (n: int) (k: code) :=
  if Int.eq (high_s_18 n) Int.zero then
    insn1 r n :: k
  else
    loadimm TMP n (insn2 r TMP :: k).

Definition opuimm (insn2: reg -> reg -> instruction)
                 (insn1: reg -> int -> instruction)
                 (r: reg) (n: int) (k: code) :=
  if Int.eq (high_u_18 n) Int.zero then
    insn1 r n :: k
  else
    loadimm TMP n (insn2 r TMP :: k).

Definition addimm (r : reg) (n: int) (k: code) := opimm Padd Paddi r n k.

Definition subimm (r: reg) (n: int) (k: code) := opimm Psub Psubi r n k.

Definition mulimm (r: reg) (n: int) (k: code) := opimm Pmul Pmuli r n k.

Definition sllimm (r: reg) (n: int) (k: code) := opimm Psll Pslil r n k.

Definition srlimm (r: reg) (n: int) (k: code) := opuimm Psrl Psril r n k.

Definition sraimm (r: reg) (n: int) (k: code) := opimm Psra Psrai r n k.

Definition rrimm (r: reg) (n: int) (k: code) := opimm Prr Prri r n k.

Definition andimm (r: reg) (n: int) (k: code) := opimm Pand Pandi r n k.

Definition nandimm (r: reg) (n: int) (k: code) := opimm Pnand Pnandi r n k.

Definition orimm (r: reg) (n: int) (k: code) := opimm Por Pori r n k.

Definition xorimm (r: reg) (n: int) (k: code) := opimm Pxor Pxori r n k.

Definition extsb (rd: reg) (k : code) :=
  Pslil rd (Int.repr 24) :: Psrai rd (Int.repr 24) :: k.

Definition extsh (rd: reg) (k : code) :=
  Pslil rd (Int.repr 16) :: Psrai rd (Int.repr 16) :: k.

Definition cmp_needs_inversion (cmp: comparison) :=
  match cmp with
  | Ceq => false
  | Cne => true
  | Clt => false
  | Cle => true
  | Cgt => false
  | Cge => true
  end.

Definition cond_needs_inversion (cond: condition) :=
  match cond with
  | Ccomp cmp => cmp_needs_inversion cmp
  | Ccompu cmp => cmp_needs_inversion cmp
  | Ccompimm cmp n => cmp_needs_inversion cmp
  | Ccompuimm cmp n => cmp_needs_inversion cmp
  (* Not really needed since double is supported *)
  | Ccompf cmp => cmp_needs_inversion cmp
  | Cnotcompf cmp => negb (cmp_needs_inversion cmp)
  (* Single version of float, needed *)
  | Ccompfs cmp => match cmp with Cne => true | _ => false end
  | Cnotcompfs cmp => match cmp with Cne => false | _ => true end
  end.

Definition transl_float_mask (cmp: comparison)
           (r1 r2: reg) (k:code) :=
  match cmp with
  | Cle => OK (Pmov_rr TMP r1 :: Pfcmp TMP r2 :: k)
  | Cge => OK (Pmov_rr TMP r1 :: Pfcmp TMP r2 :: k)
  | Ceq => OK (Pmov_rr TMP r1 :: Pfcmp TMP r2 :: Ptbi TMP (Int.repr 5) :: k)
  | Cne => OK (Pmov_rr TMP r1 :: Pfcmp TMP r2 :: Ptbi TMP (Int.repr 5) :: k)
  | Cgt => OK (Pmov_rr TMP r1 :: Pfcmp TMP r2 :: Ptbi TMP (Int.repr 6) :: k)
  | Clt => OK (Pmov_rr TMP r1 :: Pfcmp TMP r2 :: Ptbi TMP (Int.repr 7) :: k)
  end.

Definition floatcomp (cmp: comparison) (rd: reg) (r1 r2: reg) (k: code) :=
  match cmp with
  | Cle => transl_float_mask cmp r1 r2 (Pmov_rr rd TMP :: Ptbi TMP (Int.repr 5) :: Ptbi rd (Int.repr 7) :: Por rd TMP :: k)
  | Cge => transl_float_mask cmp r1 r2 (Pmov_rr rd TMP :: Ptbi TMP (Int.repr 5) :: Ptbi rd (Int.repr 6) :: Por rd TMP :: k)
  | _ => transl_float_mask cmp r1 r2 (Pmov_rr rd TMP :: k)
  end.

Definition integercmp (c: comparison) (rd: reg) (r1 r2: reg) (k: code) :=
  match c with
  | Ceq => Pcmp_eq rd r1 r2 :: k
  | Cne => Pcmp_eq rd r1 r2 :: k
  | Clt => Pcmp_lt rd r1 r2 :: k
  | Cgt => Pcmp_lt rd r2 r1 :: k
  | Cle => Pcmp_lt rd r2 r1 :: k
  | Cge => Pcmp_lt rd r1 r2 :: k
  end.

Definition integercmpu (c: comparison) (rd: reg) (r1 r2: reg) (k: code) :=
  match c with
  | Ceq => Pcmpu_eq rd r1 r2 :: k
  | Cne => Pcmpu_eq rd r1 r2 :: k
  | Clt => Pcmpu_lt rd r1 r2 :: k
  | Cgt => Pcmpu_lt rd r2 r1 :: k
  | Cle => Pcmpu_lt rd r2 r1 :: k
  | Cge => Pcmpu_lt rd r1 r2 :: k
  end.


Definition transl_cond
           (cond: condition) (args : list mreg) (r: reg) (k: code) :=
  match cond, args with
  | Ccomp c, a1 :: a2 :: nil =>
    do r1 <- reg_of a1;
    do r2 <- reg_of a2;
    OK (integercmp c r r1 r2 k)
  | Ccompu c, a1 :: a2 :: nil =>
    do r1 <- reg_of a1;
    do r2 <- reg_of a2;
    OK (integercmpu c r r1 r2 k)
  | Ccompimm c n, a1 :: nil =>
    do r1 <- reg_of a1;
    OK (loadimm TMP n (integercmp (swap_comparison c) r TMP r1 k))
  | Ccompuimm c n, a1 :: nil =>
    do r1 <- reg_of a1;
    OK (loadimm TMP n (integercmpu (swap_comparison c) r TMP r1 k))
  | Ccompf c, _ =>
    Error (msg "Double comparison not supported")
  | Cnotcompf c, _ =>
    Error (msg "Double comparison not supported")
  | Ccompfs c, a1 :: a2 :: nil =>
    do r1 <- reg_of a1; do r2 <- reg_of a2; (floatcomp c r r1 r2 k)
  | Cnotcompfs c, a1 :: a2 :: nil =>
    do r1 <- reg_of a1; do r2 <- reg_of a2; (floatcomp c r r1 r2 k)
  | _, _ =>
    Error (msg "Asmgen.transl_cond")
  end.

(** Translation of a condition operator.  The generated code sets
  the [r] target register to 0 or 1 depending on the truth value of the
  condition. *)

(** Translation of a conditional branch.  Prepends to [k] the instructions
  that evaluate the condition and branch to [lbl] if it holds.
  We recognize some conditional branches that can be implemented
  without setting then testing condition flags.  *)

Definition transl_cond_branch_default (cond: condition) (args: list mreg)
           (lbl: label) (k: code) :=
  transl_cond cond args TMP
    (if (cond_needs_inversion cond) then Pbz TMP lbl :: k else Pbnz TMP lbl :: k).

Definition transl_cond_branch
              (c: condition) (args: list mreg) (lbl: label) (k: code) :=
  match c, args with
  | Ccompimm Cne n, a1 :: nil =>
    do r1 <- reg_of a1;
    if Int.eq n Int.zero
    then OK (Pbnz r1 lbl :: k)
    else OK (loadimm TMP n (Pxor TMP r1 :: Pbnz TMP lbl :: k))
  | Ccompuimm Cne n, a1 :: nil =>
    if Int.eq n Int.zero
    then (do r1 <- reg_of a1; OK (Pbnz r1 lbl :: k))
    else transl_cond_branch_default c args lbl k
  | Ccompimm Ceq n, a1 :: nil =>
    do r1 <- reg_of a1;
    if Int.eq n Int.zero
    then OK (Pbz r1 lbl :: k)
    else OK (loadimm TMP n (Pxor TMP r1 :: Pbz TMP lbl :: k))
  | Ccompuimm Ceq n, a1 :: nil =>
    if Int.eq n Int.zero
    then (do r1 <- reg_of a1; OK (Pbz r1 lbl :: k))
    else transl_cond_branch_default c args lbl k
  | Ccompimm Clt n, a1 :: nil =>
    if Int.eq n Int.zero
    then (do r1 <- reg_of a1; OK (Pbm r1 lbl :: k))
    else transl_cond_branch_default c args lbl k
  | Ccompimm Cle n, a1 :: nil =>
    if Int.eq n Int.zero
    then (do r1 <- reg_of a1; OK (Pbmz r1 lbl :: k))
    else transl_cond_branch_default c args lbl k
  | Ccompimm Cge n, a1 :: nil =>
    if Int.eq n Int.zero
    then (do r1 <- reg_of a1; OK (Pbnm r1 lbl :: k))
    else transl_cond_branch_default c args lbl k
  | Ccomp Ceq, a1 :: a2 :: nil =>
    do r1 <- reg_of a1;
    do r2 <- reg_of a2;
    OK (Pmov_rr TMP r1 :: Pxor TMP r2 :: Pbz TMP lbl :: k)
  | Ccomp Cne, a1 :: a2 :: nil =>
    do r1 <- reg_of a1;
    do r2 <- reg_of a2;
    OK (Pmov_rr TMP r1 :: Pxor TMP r2 :: Pbnz TMP lbl :: k)
  | Ccompfs cmp, a1 :: a2 :: nil =>
    do r1 <- reg_of a1;
    do r2 <- reg_of a2;
    match cmp with
    | Cne => transl_float_mask cmp r1 r2 (Pbz TMP lbl :: k)
    | Cle => transl_float_mask cmp r1 r2 (Pandi TMP (Int.repr 160) :: Pbnz TMP lbl :: k)
    | Cge => transl_float_mask cmp r1 r2 (Pandi TMP (Int.repr 96) :: Pbnz TMP lbl :: k)
    | _ => transl_float_mask cmp r1 r2 (Pbnz TMP lbl :: k)
    end
  | Cnotcompfs cmp, a1 :: a2 :: nil =>
    do r1 <- reg_of a1;
    do r2 <- reg_of a2;
    match cmp with
    | Cne => transl_float_mask cmp r1 r2 (Pbnz TMP lbl :: k)
    | Cle => transl_float_mask cmp r1 r2 (Pandi TMP (Int.repr 160) :: Pbz TMP lbl :: k)
    | Cge => transl_float_mask cmp r1 r2 (Pandi TMP (Int.repr 96) :: Pbz TMP lbl :: k)
    | _ => transl_float_mask cmp r1 r2 (Pbz TMP lbl :: k)
    end
  | _, _ =>
    transl_cond_branch_default c args lbl k
  end.

(** Translation of the arithmetic operation [r <- op(args)].
  The corresponding instructions are prepended to [k]. *)

Definition transl_op
           (op: operation) (args: list mreg) (res: mreg) (k: code) :=
   match op, args with
   | Omove, a1 :: nil =>
     match preg_of res, preg_of a1 with
     | GPR rd, GPR r => OK (Pmov_rr rd r :: k)
     | _, _ => Error (msg "Asmgen.Omove")
     end
   | Ointconst n, nil =>
     do r <- reg_of res;
     OK (loadimm r n k)
   | Osingleconst f, nil =>
     do r <- reg_of res;
     OK (Pmov_rs r f :: k)
   | Ofloatconst _, nil =>
     Error (msg "Double constants are not supported")
   | Oaddrsymbol id ofs, nil =>
     do r <- reg_of res;
     OK (Ploadsymbol r id ofs :: k)
   | Oaddrstack ofs, nil =>
     do r <- reg_of res;
     OK (Pmov_rr r SP :: (addimm r (Ptrofs.to_int ofs) k))
   | Ocast8signed, a1 :: nil =>
     do r <- reg_of a1; do rd <- reg_of res;
     OK (Pmov_rr rd r :: extsb rd k)
   | Ocast16signed, a1 :: nil =>
     do r <- reg_of a1; do rd <- reg_of res;
     OK (Pmov_rr rd r :: extsh rd k)
   | Oadd, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Padd rd r :: k)
   | Oaddimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (addimm rd n k)
   | Osub, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Psub rd r :: k)
   | Osubimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (subimm rd n k)
   | Omul, a1 :: a2 :: nil =>
     assertion(mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Pmul rd r :: k)
   | Omulimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (mulimm rd n k)
   | Omulhs, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Pmulh rd r :: k)
   | Omulhu, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Pmulhu rd r :: k)
   | Odiv, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Pdiv rd r :: k)
   | Odivu, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Pdivu rd r :: k)
   | Omod, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Prem rd r :: k)
   | Omodu, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Premu rd r :: k)
   | Omadd, a1 :: a2 :: a3 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; do r1 <- reg_of a2; do r2 <- reg_of a3; OK (Pmad rd r1 r2 :: k)
   | Omsub, a1 :: a2 :: a3 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; do r1 <- reg_of a2; do r2 <- reg_of a3; OK (Pmsu rd r1 r2 :: k)
   | Oor, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Por rd r :: k)
   | Oorimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (orimm rd n k)
   | Oand, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Pand rd r :: k)
   | Oandimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (andimm rd n k)
   | Onand, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Pnand rd r :: k)
   | Onandimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (nandimm rd n k)
   | Oxor, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Pxor rd r :: k)
   | Oxorimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (xorimm rd n k)
   | Oshr, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Psra rd r :: k)
   | Oshrimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (sraimm rd n k)
   | Oshl, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Psll rd r :: k)
   | Oshlimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (sllimm rd n k)
   | Oshru, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do r <- reg_of a2; do rd <- reg_of res; OK (Psrl rd r :: k)
   | Oshruimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (srlimm rd n k)
   | Ororimm n, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; OK (rrimm rd n k)
   | Oshrximm n, a1:: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res;
     OK (if Int.eq n Int.zero then Pmov_rr rd rd :: k else
           Pmov_rr TMP rd ::
           Psrai TMP (Int.repr 31) ::
           Psril TMP (Int.sub Int.iwordsize n) ::
           Padd TMP rd ::
           Psrai TMP n ::
           Pmov_rr rd TMP ::k)
   | Onegf, _ =>
     Error (msg "Neg for double is not supported")
   | Oabsf, _ =>
     Error (msg "Absf for double is not supported")
   | Oaddf, _ =>
     Error (msg "Addf for double is not supported")
   | Osubf, _ =>
     Error (msg "Subf for double is not supported")
   | Omulf, _ =>
     Error (msg "Mulf for double is not supported")
   | Odivf, _ =>
     Error (msg "Divf for double is not supported")
   | Onegfs, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res;
     OK (Pfneg rd :: k)
   | Oabsfs, a1 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res;
     OK (Pfabs rd :: k)
   | Oaddfs, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res;
     do r <- reg_of a2;
     OK (Pfadds rd r :: k)
   | Osubfs, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; do r <- reg_of a2; OK (Pfsubs rd r :: k)
   | Omulfs, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; do r <- reg_of a2; OK (Pfmuls rd r :: k)
   | Odivfs, a1 :: a2 :: nil =>
     assertion (mreg_eq a1 res);
     do rd <- reg_of res; do r <- reg_of a2; OK (Pfdivs rd r :: k)
   | Osingleoffloat, _ =>
     Error (msg "Single to dobule conversion is not supported")
   | Ofloatofsingle, _ =>
     Error (msg "Double to single conversion is not supported")
   | Ointoffloat, _ =>
     Error (msg "Double to signed int conversion is not supported")
   | Ointuoffloat, _ =>
     Error (msg "Double to unsigned int conversion is not supported")
   | Ofloatofint, _ =>
     Error (msg "Signed int to double conversion is not supported")
   | Ofloatofintu, _ =>
     Error (msg "Unsigned int to double conversion is not supported")
   | Ointofsingle, a1 :: nil =>
     do rd <- reg_of res;
     do r <- reg_of a1;
     OK (Pff2i rd r :: k)
   | Ointuofsingle, a1 :: nil =>
     do rd <- reg_of res;
     do r <- reg_of a1;
     OK (Pff2iu rd r :: k)
   | Osingleofint, a1 :: nil =>
     do rd <- reg_of res;
     do r <- reg_of a1;
     OK (Pfi2f rd r :: k)
   | Osingleofintu, a1 :: nil =>
     do rd <- reg_of res;
     do r <- reg_of a1;
     OK (Pfiu2f rd r :: k)
   | Ocmp cond, args =>
     do rd <- reg_of res;
     transl_cond cond args rd
      (if (cond_needs_inversion cond)
       then Pxori rd Int.one :: k
       else k)
   | _, _ =>
      Error(msg "Asmgen.transl_op")
   end.

(** Accessing data in the stack frame. *)

Definition accessind
           (instr: addressing -> instruction)
           (base: reg) (ofs: ptrofs) (k: code) :=
  let ofs := Ptrofs.to_int ofs in
  if Int.eq (high_s_20 ofs) Int.zero
  then instr (ADimm base ofs) :: k
  else  loadimm TMP ofs (instr (ADreg base TMP) :: k).


Definition loadind (base: reg) (ofs: ptrofs) (ty: typ) (dst: mreg) (k: code) : res code :=
  match ty, preg_of dst with
  | Tint, GPR rd => OK (accessind (Pmov_mr rd) base ofs k)
  | Tany32, GPR rd => OK (accessind (Pmov_mr_a rd) base ofs k)
  | Tsingle, GPR rd => OK (accessind (Pfmov_mr rd) base ofs k)
  | _, _ =>
    Error (msg "Asmgen.loadind")
  end.

Definition storeind (src: mreg) (base: reg) (ofs: ptrofs) (ty: typ) (k: code) : res code :=
  match ty, preg_of src with
  | Tint, GPR rd => OK (accessind (fun a => Pmov_rm a rd) base ofs k)
  | Tany32, GPR rd => OK (accessind (fun a => Pmov_rm_a a rd) base ofs k)
  | Tsingle, GPR rd => OK (accessind (fun a => Pfmov_rm a rd) base ofs k)
  | _, _ =>
    Error (msg "Asmgen.storeind")
  end.

Definition storeptr (src: reg) (base: reg) (ofs: ptrofs) (k: code) :=
  accessind (fun a => Pmov_rm a src) base ofs k.

Definition loadptr (base: reg) (ofs: ptrofs) (dst: reg) (k: code) :=
  accessind (Pmov_mr dst) base ofs k.

(** Translation of memory accesses: loads, and stores. *)

Definition transl_memory_access
     (instr: addressing -> instruction)
     (addr: Op.addressing) (args: list mreg) (k: code) : res code :=
  match addr, args with
  | Aindexed ofs, a1 :: nil =>
    do rs <- reg_of a1;
    if Int.eq (high_s_20 ofs) Int.zero
    then OK (instr (ADimm rs ofs) :: k)
    else OK (loadimm TMP ofs (instr (ADreg rs TMP) :: k))
  | Aglobal id ofs, nil =>
    OK (Ploadsymbol TMP id ofs :: instr (ADimm TMP Int.zero) :: k)
  | Ainstack ofs, nil =>
    OK (accessind instr SP ofs k)
  | _, _ =>
      Error(msg "Asmgen.transl_memory_access")
  end.

Definition transl_load (chunk: memory_chunk) (addr: Op.addressing)
           (args: list mreg) (dst: mreg) (k: code) : res code :=
  match chunk with
  | Mint8signed =>
    do r <- reg_of dst;
    transl_memory_access (Pmovsb_mr r) addr args k
  | Mint8unsigned =>
    do r <- reg_of dst;
    transl_memory_access (Pmovb_mr r) addr args k
  | Mint16signed =>
    do r <- reg_of dst;
    transl_memory_access (Pmovsh_mr r) addr args k
  | Mint16unsigned =>
    do r <- reg_of dst;
    transl_memory_access (Pmovh_mr r) addr args k
  | Mint32 =>
    do r <- reg_of dst;
    transl_memory_access (Pmov_mr r)  addr args k
  | Mfloat32 =>
    do r <- reg_of dst;
    transl_memory_access (Pfmov_mr r)  addr args k
  | _ =>
    Error (msg "Asmgen.transl_load")
  end.

Definition transl_store (chunk: memory_chunk) (addr: Op.addressing)
           (args: list mreg) (src: mreg) (k: code) : res code :=
  match chunk with
  | Mint8signed | Mint8unsigned =>
    do r <- reg_of src;
    transl_memory_access (fun a => Pmovb_rm a r) addr args k
  | Mint16signed | Mint16unsigned =>
    do r <- reg_of src;
    transl_memory_access (fun a => Pmovh_rm a r) addr args k
  | Mint32 =>
    do r <- reg_of src;
    transl_memory_access (fun a => Pmov_rm a r) addr args k
  | Mfloat32 =>
    do r <- reg_of src;
    transl_memory_access (fun a => Pfmov_rm a r) addr args k
  | _ =>
    Error (msg "Asmgen.transl_store")
  end.

(** Function epilogue: reload return address into register LR and
    free the stack frame.  No need to reload the return address if
    this is a tail function. *)

Definition transl_epilogue (f: Mach.function) (k: code) :=
  loadptr SP f.(fn_retaddr_ofs) TMP
   (Pmov_tcrp TMP ::
     Pfreeframe f.(fn_stacksize) f.(fn_link_ofs) :: k).

(** Translation of a Mach instruction. *)

Definition transl_instr (f: Mach.function) (i: Mach.instruction)
           (r2_is_parent: bool) (k: code) :=
  match i with
  | Mgetstack ofs ty dst =>
    loadind SP ofs ty dst k
  | Msetstack src ofs ty =>
    storeind src SP ofs ty k
  | Mgetparam ofs ty dst =>
    do c <- loadind Reg2 ofs ty dst k;
    OK (if r2_is_parent then c
        else loadptr SP f.(fn_link_ofs) Reg2 c)
  | Mop op args res =>
    transl_op op args res k
  | Mload chunk addr args dst =>
    transl_load chunk addr args dst k
  | Mstore chunk addr args src =>
    transl_store chunk addr args src k
  | Mcall sig (inl reg) =>
    do r <- reg_of reg; OK (Pjmp_p r sig :: k)
  | Mcall sig (inr symb) =>
    OK (Pjmp_sp symb sig :: k)
  | Mtailcall sig (inl reg) =>
    do r <- reg_of reg;
    OK (transl_epilogue f (Pjmp r sig :: k))
  | Mtailcall sig (inr symb) =>
    OK (transl_epilogue f (Pjmp_s symb sig :: k))
  | Mbuiltin ef args res =>
    OK (Pbuiltin ef (List.map (map_builtin_arg preg_of) args) (map_builtin_res preg_of res) :: k)
  | Mlabel lbl =>
    OK(Plabel lbl :: k)
  | Mgoto lbl =>
    OK (Pjmp_l lbl :: k)
  | Mcond cond args lbl =>
    transl_cond_branch cond args lbl k
  | Mjumptable arg tbl =>
    do r <- reg_of arg; OK (Pbtbl r tbl :: k)
  | Mreturn =>
     OK (transl_epilogue f (Pret :: k))
  end.
(** Translation of a code sequence *)

Definition it1_is_parent (before: bool) (i: Mach.instruction) : bool :=
  match i with
  | Msetstack src ofs ty => before
  | Mgetparam ofs ty dst => negb (mreg_eq dst R2)
  | Mop Omove args res => before && negb (mreg_eq res R2)
  | _ => false
  end.

Definition save_lr (ofs: ptrofs) (k: code) :=
  let ofs' := Ptrofs.to_int ofs in
  if Int.eq (high_s_20 ofs') Int.zero
  then
    Pmov_fcrp TMP :: Pmov_rm (ADimm SP ofs') TMP :: k
  else
    Pmov_fcrp Reg2 :: storeptr Reg2 SP ofs k.


Definition save_lr_preserves_Reg2 (ofs: ptrofs) : bool :=
  let ofs := Ptrofs.to_int ofs in
  Int.eq (high_s_20 ofs) Int.zero.


(** This is the naive definition that we no longer use because it
  is not tail-recursive.  It is kept as specification. *)

Fixpoint transl_code (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  match il with
  | nil => OK nil
  | i1 :: il' =>
      do k <- transl_code f il' (it1_is_parent it1p i1);
      transl_instr f i1 it1p k
  end.

(** This is an equivalent definition in continuation-passing style
  that runs in constant stack space. *)

Fixpoint transl_code_rec (f: Mach.function) (il: list Mach.instruction)
                         (it1p: bool) (k: code -> res code) :=
  match il with
  | nil => k nil
  | i1 :: il' =>
      transl_code_rec f il' (it1_is_parent it1p i1)
        (fun c1 => do c2 <- transl_instr f i1 it1p c1; k c2)
  end.

Definition transl_code' (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  transl_code_rec f il it1p (fun c => OK c).


(** Translation of a whole function.  Note that we must check
  that the generated code contains less than [2^32] instructions,
  otherwise the offset part of the [PC] code pointer could wrap
  around, leading to incorrect executions. *)

Definition transl_function (f: Mach.function) : res Asm.function :=
  do c <- transl_code' f f.(Mach.fn_code) (save_lr_preserves_Reg2 f.(fn_retaddr_ofs));
  OK (mkfunction f.(Mach.fn_sig)
      (Pallocframe f.(fn_stacksize) f.(fn_link_ofs)  ::
        save_lr f.(fn_retaddr_ofs) c)).

Definition transf_function (f: Mach.function) : res Asm.function :=
  do tf <- transl_function f;
  if zlt Ptrofs.max_unsigned (list_length_z tf.(fn_code))
  then Error (msg "code size exceeded")
  else OK tf.

Definition transf_fundef (f: Mach.fundef) : res Asm.fundef :=
  transf_partial_fundef transf_function f.

Definition transf_program (p: Mach.program) : res Asm.program :=
  transform_partial_program transf_fundef p.
