(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Xavier Leroy, INRIA Paris-Rocquencourt                     *)
(*                                                                     *)
(*  Copyright Institut National de Recherche en Informatique et en     *)
(*  Automatique.  All rights reserved.  This file is distributed       *)
(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
(*                                                                     *)
(* *********************************************************************)

(** Translation from Mach to PPC. *)

Require Import Coqlib.
Require Import Errors.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Op.
Require Import Locations.
Require Import Mach.
Require Import Asm.

Local Open Scope string_scope.
Local Open Scope error_monad_scope.

(** The code generation functions take advantage of several
  characteristics of the [Mach] code generated by earlier passes of the
  compiler, mostly that argument and result registers are of the correct
  types.  These properties are true by construction, but it's easier to
  recheck them during code generation and fail if they do not hold. *)

(** Extracting integer or float registers. *)

Definition ireg_of (r: mreg) : res ireg :=
  match preg_of r with IR mr => OK mr | _ => Error(msg "Asmgen.ireg_of") end.

Definition freg_of (r: mreg) : res freg :=
  match preg_of r with FR mr => OK mr | _ => Error(msg "Asmgen.freg_of") end.

(** Smart constructor for move from register to register. The se_mr instruction
    can only move between registers GPR0 - GPR7 and GPR 24 - GPR31 so if we
    want to move from from this range to GRP8-GPR23 we need to use the instruction
    se_mtar and for the other way around se_mfar.
    Moves between registers in the alternate register are performed by using an or.
 *)


Definition move_rr_base (rd r: ireg) (k: code) :=
  match rd, r with
    | Sreg rd, Sreg r => Pse_mr rd r :: k
    | Sreg rd, Areg r => Pse_mfar rd r :: k
    | Areg rd, Sreg r => Pse_mtar rd r :: k
    | Areg rd, Areg r => Pmr rd r :: k
    end.

Definition move_rr (rd r: ireg) (k: code) :=
  if ireg_eq rd r then
    k
  else
    move_rr_base rd r k.

(** Translation function for operation that chooses between the short and normal encoding
    If the instruction is commutative we also want to select the short encoding if the
    target and the second argument match.
 *)
Definition select_encoding_instr
           (instr1 : sreg -> sreg -> instruction)
           (instr2 : ireg -> ireg -> ireg -> instruction)
           (commut: bool) (rd r1 r2: ireg) (k: code) :=
  match rd, r1, r2 with
  | Sreg srd, Sreg sr1, Sreg sr2 =>
    if sreg_eq srd sr1 then
      instr1 srd sr2 :: k
    else if commut && sreg_eq srd sr2 then
      instr1 srd sr1 :: k
    else
      instr2 rd r1 r2 :: k
  | _, _, _ => instr2 rd r1 r2 :: k
  end.

(** Decomposition of integer constants.  As noted in file [Asm],
  immediate arguments to PowerPC instructions must fit into 16 bits,
  and are interpreted after zero extension, sign extension, or
  left shift by 16 bits, depending on the instruction.  Integer
  constants that do not fit must be synthesized using two
  processor instructions.  The following functions decompose
  arbitrary 32-bit integers into two 16-bit halves (high and low
  halves).  They satisfy the following properties:
- [low_u n] is an unsigned 16-bit integer;
- [low_s n] is a signed 16-bit integer;
- [(high_u n) << 16 | low_u n] equals [n];
- [(high_s n) << 16 + low_s n] equals [n].
  Additionally there exists some instructions that support 20 bits
  immediates. The following functions decomppse arbitrary 32-bit
  integers into a lower 20-bit halve and a high 12-bit halve:
- [low_s_20 n] is a signed 20-bit integer;
- [(high_s_12 n) << 20 + low_s_20 n] equals [n].
*)

Definition low_u (n: int) := Int.and n (Int.repr 65535).
Definition high_u (n: int) := Int.shru n (Int.repr 16).
Definition low_s (n: int) := Int.sign_ext 16 n.
Definition high_s (n: int) := Int.shru (Int.sub n (low_s n)) (Int.repr 16).
Definition low_s_20 (n: int) := Int.sign_ext 20 n.
Definition high_s_12 (n: int) := Int.shru (Int.sub n (low_s_20 n)) (Int.repr 20).

(** Check if an immediate is in oim5 format *)
Definition is_oim5 (n: int) := Int.lt Int.zero n && Int.lt n (Int.repr 33).

(** Smart constructors for arithmetic operations involving
  a 32-bit integer constant.  Depending on whether the
  constant fits in 16 bits or not, one or several instructions
  are generated as required to perform the operation
  and prepended to the given instruction sequence [k]. *)

Definition loadimm_default (r: ireg) (n: int) (k:code) :=
  if Int.eq (Int.shru n (Int.repr 7)) Int.zero then
    match r with
    | Sreg r => Pse_li r n :: k
    | Areg r => Pe_li r (Cint n) :: k
    end
  else if Int.eq (high_s_12 n) Int.zero then
    Pe_li r (Cint n) :: k
  else if Int.eq (low_s n) Int.zero then
    Pe_lis r (Cint (high_s n)) :: k
  else
    Pe_lis r (Cint (high_u n)) ::
    Pe_or2i r (Cint (low_u n)) :: k.

Definition loadimm (r: ireg) (n: int) (k: code) :=
  match r, Int.is_power2 n with
  | Sreg r, Some i =>
    let i := Int.sub (Int.repr 31) i in
    Pse_bgeni r i :: k
  | _, _ => loadimm_default r n k
  end.

Definition addi_low (r1 r2 :ireg) (n: int) (k: code) :=
  match r1 with
  | Sreg s1 =>
    if  ireg_eq r1 r2 && is_oim5 n then
      Pse_addi s1 n :: k
    else if  ireg_eq r1 r2 &&  is_oim5 (Int.neg n) then
      Pse_subi s1 (Int.neg n) :: k
    else
      Pe_add16i r1 r2 (Cint n) :: k
  | _ =>  Pe_add16i r1 r2 (Cint n) :: k
  end.

Definition addimm (r1 r2 : ireg) (n: int) (k: code) :=
  if Int.eq (high_s n) Int.zero then
    addi_low r1 r2 n k
  else if Int.eq (low_s n) Int.zero then
    move_rr r1 r2 (Pe_add2is r1 (Cint (high_s n)) :: k)
  else
    addi_low r1 r2 (low_s n) (Pe_add2is r1 (Cint (high_s n)) :: k).

Definition andimm_base (r1 r2: ireg) (n: int) (k: code) :=
  if Int.eq (high_u n) Int.zero then
    move_rr r1 r2 (Pe_and2i_ r1 (Cint n) :: k)
  else if Int.eq (low_u n) Int.zero then
    move_rr r1 r2 (Pe_and2is_ r1 (Cint (high_u n)) :: k)
  else
    loadimm GPR0 n (select_encoding_instr Pse_and_ Pand_ true r1 r2 GPR0 k).

Definition andimm (r1 r2: ireg) (n: int) (k: code) :=
  if is_rlw_mask n then
    Pe_rlwinm r1 r2 Int.zero n :: k
  else
    andimm_base r1 r2 n k.

Definition orimm (r1 r2: ireg) (n: int) (k: code) :=
  if Int.eq (high_u n) Int.zero then
    move_rr r1 r2 (Pe_or2i r1 (Cint n) :: k)
  else if Int.eq (low_u n) Int.zero then
    move_rr r1 r2 (Pe_or2is r1 (Cint (high_u n)) :: k)
  else
    move_rr r1 r2 (Pe_or2is r1 (Cint (high_u n)) ::
                    Pe_or2i r1 (Cint (low_u n)) :: k).

Definition xorimm (r1 r2: ireg) (n: int) (k: code) :=
  if Int.eq (Int.shru n (Int.repr 8)) Int.zero then
    Pe_xori r1 r2 n :: k
  else
    loadimm GPR0 n (Pxor r1 r2 GPR0 :: k).

Definition rolm (r1 r2: ireg) (amount mask: int) (k: code) :=
  if is_rlw_mask mask then
    Pe_rlwinm r1 r2 amount mask :: k
  else
    Pe_rlwinm r1 r2 amount Int.mone :: andimm_base r1 r1 mask k .

Definition shrimm (r1 r2: ireg) (n: int) (k: code) :=
  let default := Psrawi r1 r2 n :: k in
  match r1, r2 with
  | Sreg s1, Sreg s2 =>
    if sreg_eq s1 s2 then
      Pse_srawi s1 n :: k
    else
      default
  | _, _ => default
  end.

(** Constructor for a floating-point comparison.  The PowerPC VLE has
  three instructions to compare floats, which all set bit 2 of the
  condition register.
  The ``less or equal'' and ``greater or equal'' conditions must be
  synthesized by executing both comparisons and a [cror] instruction
  that computes the logical ``or'' of the corresponding two conditions. *)

Definition floatcomp (cmp: comparison) (r1 r2: ireg) (k: code) :=
  match cmp with
  | Ceq => Pefscmpeq r1 r2 :: k
  | Cne => Pefscmpeq r1 r2 :: k
  | Cgt => Pefscmpgt r1 r2 :: k
  | Clt => Pefscmplt r1 r2 :: k
  | Cge => Pefscmpeq r1 r2 :: Pefscmpgt r1 r2 :: Pe_cror CRbit_3 CRbit_5 CRbit_1 :: k
  | Cle => Pefscmpeq r1 r2 :: Pefscmplt r1 r2 :: Pe_cror CRbit_3 CRbit_5 CRbit_1 :: k
  end.


(** Translation of a condition.  Prepends to [k] the instructions
  that evaluate the condition and leave its boolean result in one of
  the bits of the condition register.  The bit in question is
  determined by the [crbit_for_cond] function. *)

Definition transl_cond
              (cond: condition) (args: list mreg) (k: code) :=
  match cond, args with
  | Ccomp c, a1 :: a2 :: nil =>
    do r1 <- ireg_of a1;
    do r2 <- ireg_of a2;
    match r1, r2 with
    | Sreg r1, Sreg r2 =>  OK (Pse_cmp r1 r2 :: k)
    | _, _ => OK (Pcmpw r1 r2 :: k)
    end
  | Ccompu c, a1 :: a2 :: nil =>
    do r1 <- ireg_of a1;
    do r2 <- ireg_of a2;
    match r1, r2 with
    | Sreg r1, Sreg r2 =>  OK (Pse_cmpl r1 r2 :: k)
    | _, _ => OK (Pcmplw r1 r2 :: k)
    end
  | Ccompimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      if Int.eq (Int.shru n (Int.repr 5)) Int.zero then
        match r1 with
        | Sreg r1 => OK (Pse_cmpi r1 n :: k)
        |  _ => OK (Pe_cmp16i r1 (Cint n) :: k)
        end
      else if Int.eq (high_s n) Int.zero then
        OK (Pe_cmp16i r1 (Cint n) :: k)
      else
        OK (loadimm GPR0 n (Pcmpw r1 GPR0 :: k))
  | Ccompuimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      if Int.eq (high_u n) Int.zero then
        OK (Pe_cmpl16i r1 (Cint n) :: k)
      else
        OK (loadimm GPR0 n (Pcmplw r1 GPR0 :: k))
  | Ccompfs cmp, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; OK (floatcomp cmp r1 r2 k)
  | Cnotcompfs cmp, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; OK (floatcomp cmp r1 r2 k)
  | Cmaskzero n, a1 :: nil =>
      do r1 <- ireg_of a1; OK (andimm_base GPR0 r1 n k)
  | Cmasknotzero n, a1 :: nil =>
      do r1 <- ireg_of a1; OK (andimm_base GPR0 r1 n k)
  | _, _ =>
      Error(msg "Asmgen.transl_cond")
  end.

(*  Integer:
     CRbit_0 = Less
     CRbit_1 = Greater
     CRbit_2 = Equal

    Floating Point:
     CRbit_1 = Equal
     CRbit_3 = Other
     CRbit_5 = Less/Greater
 *)

Definition crbit_for_icmp (cmp: comparison) :=
  match cmp with
  | Ceq => (CRbit_2, true)
  | Cne => (CRbit_2, false)
  | Clt => (CRbit_0, true)
  | Cle => (CRbit_1, false)
  | Cgt => (CRbit_1, true)
  | Cge => (CRbit_0, false)
  end.

Definition crbit_for_fcmp (cmp: comparison) :=
  match cmp with
  | Ceq => (CRbit_1, true)
  | Cne => (CRbit_1, false)
  | Clt => (CRbit_5, true)
  | Cle => (CRbit_3, true)
  | Cgt => (CRbit_5, true)
  | Cge => (CRbit_3, true)
  end.

Definition crbit_for_cond (cond: condition) :=
  match cond with
  | Ccomp cmp => crbit_for_icmp cmp
  | Ccompu cmp => crbit_for_icmp cmp
  | Ccompimm cmp n => crbit_for_icmp cmp
  | Ccompuimm cmp n => crbit_for_icmp cmp
  | Ccompf cmp => crbit_for_fcmp cmp
  | Cnotcompf cmp => let p := crbit_for_fcmp cmp in (fst p, negb (snd p))
  | Ccompfs cmp => crbit_for_fcmp cmp
  | Cnotcompfs cmp => let p := crbit_for_fcmp cmp in (fst p, negb (snd p))
  | Cmaskzero n => (CRbit_2, true)
  | Cmasknotzero n => (CRbit_2, false)
  end.

(** Recognition of comparisons [>= 0] and [< 0]. *)

Inductive condition_class: condition -> list mreg -> Type :=
  | condition_eq0:
      forall n r, n = Int.zero -> condition_class (Ccompimm Ceq n) (r :: nil)
  | condition_ne0:
      forall n r, n = Int.zero -> condition_class (Ccompimm Cne n) (r :: nil)
  | condition_ge0:
      forall n r, n = Int.zero -> condition_class (Ccompimm Cge n) (r :: nil)
  | condition_lt0:
      forall n r, n = Int.zero -> condition_class (Ccompimm Clt n) (r :: nil)
  | condition_default:
      forall c rl, condition_class c rl.

Definition classify_condition (c: condition) (args: list mreg): condition_class c args :=
  match c as z1, args as z2 return condition_class z1 z2 with
  | Ccompimm Ceq n, r :: nil =>
      match Int.eq_dec n Int.zero with
      | left EQ => condition_eq0 n r EQ
      | right _ => condition_default (Ccompimm Ceq n) (r :: nil)
      end
  | Ccompimm Cne n, r :: nil =>
      match Int.eq_dec n Int.zero with
      | left EQ => condition_ne0 n r EQ
      | right _ => condition_default (Ccompimm Cne n) (r :: nil)
      end
  | Ccompimm Cge n, r :: nil =>
      match Int.eq_dec n Int.zero with
      | left EQ => condition_ge0 n r EQ
      | right _ => condition_default (Ccompimm Cge n) (r :: nil)
      end
  | Ccompimm Clt n, r :: nil =>
      match Int.eq_dec n Int.zero with
      | left EQ => condition_lt0 n r EQ
      | right _ => condition_default (Ccompimm Clt n) (r :: nil)
      end
  | x, y =>
      condition_default x y
  end.

(** Translation of a condition operator.  The generated code sets
  the [r] target register to 0 or 1 depending on the truth value of the
  condition. *)

Definition transl_cond_op
             (cond: condition) (args: list mreg) (r: mreg) (k: code) :=
  do r' <- ireg_of r;
  match classify_condition cond args with
  | condition_eq0 _ a _ =>
      do a' <- ireg_of a;
      OK (Pe_subfic GPR0 a' Int.zero ::
          Padde r' GPR0 a' :: k)
  | condition_ne0 _ a _ =>
      do a' <- ireg_of a;
      OK (Pe_addic GPR0 a' Int.mone ::
          Psubfe r' GPR0 a' :: k)
  | condition_ge0 _ a _ =>
      do a' <- ireg_of a;
      OK (Pe_rlwinm r' a' Int.one Int.one ::
          Pe_xori r' r' Int.one :: k)
  | condition_lt0 _ a _ =>
      do a' <- ireg_of a;
      OK (Pe_rlwinm r' a' Int.one Int.one :: k)
  | condition_default _ _ =>
      let p := crbit_for_cond cond in
      transl_cond cond args
        (Pmfcrbit r' (fst p) ::
         if snd p
         then k
         else Pe_xori r' r' Int.one :: k)
  end.

(** Translation of a select operation *)

Definition transl_select_op
              (cond: condition) (args: list mreg) (r1 r2 rd: ireg) (k: code) :=
  if ireg_eq r1 r2 then
    OK (move_rr_base rd r1 k) (* We need a move here *)
  else
   (let p := crbit_for_cond cond in
    let r1' := if snd p then r1 else r2 in
    let r2' := if snd p then r2 else r1 in
    transl_cond cond args (Pisel rd r1' r2' (fst p) :: k)).

(** Translation of the arithmetic operation [r <- op(args)].
  The corresponding instructions are prepended to [k]. *)

Definition transl_op
              (op: operation) (args: list mreg) (res: mreg) (k: code) :=
  match op, args with
  | Omove, a1 :: nil =>
      match preg_of res, preg_of a1 with
      | IR r, IR a => OK (move_rr_base r a k) (* We need a move here *)
      | _   , _    => Error(msg "Asmgen.Omove")
      end
  | Ointconst n, nil =>
      do r <- ireg_of res; OK (loadimm r n k)
  | Osingleconst f, nil =>
      do r <- ireg_of res; OK (Plfis r f :: k)
  | Oaddrsymbol s ofs, nil =>
      do r <- ireg_of res;
      OK (if symbol_is_small_data s ofs then
           Pe_li r (Csymbol_sda s ofs) :: k
         else if symbol_is_rel_data s ofs then
           (* dcc uses the following pattern:

              e_add16i r, r0, s@sdarx@l
              e_add2is r, i@sdarx@h

              and replaces the r0 with the sda register.
              However in order that this works for the gcc we need r0 to hold
              zero.
            *)
           Pse_li GPR0 Int.zero ::
           Pe_add16i r GPR0 (Csymbol_rel_low s ofs) ::
           Pe_add2is r (Csymbol_rel_high s ofs) :: k
         else
           Pe_lis r (Csymbol_high s ofs) ::
           Pe_add16i r r (Csymbol_low s ofs) :: k)
  | Oaddrstack n, nil =>
      do r <- ireg_of res; OK (addimm r GPR1 (Ptrofs.to_int n) k)
  | Ocast8signed, a1 :: nil =>
      do r1 <- ireg_of a1;
      do r <- ireg_of res;
      OK (match r with
          | Sreg s => move_rr s r1 (Pse_extsb s :: k)
          | _ => Pextsb r r1 :: k
          end)
  | Ocast16signed, a1 :: nil =>
      do r1 <- ireg_of a1;
      do r <- ireg_of res;
      OK (match r with
          | Sreg s =>  move_rr s r1 (Pse_extsh s :: k)
          | _ => Pextsh r r1 :: k
          end)
  | Oadd, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (select_encoding_instr Pse_add Padd true r r1 r2 k)
  | Oaddimm n, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res; OK (addimm r r1 n k)
  | Oaddsymbol s ofs, a1 :: nil =>
       do r1 <- ireg_of a1; do r <- ireg_of res;
       OK (if symbol_is_small_data s ofs then
             Pe_li GPR0 (Csymbol_sda s ofs) ::
             Padd r r1 GPR0 :: k
           else if symbol_is_rel_data s ofs then
             (* Similar to the one from Oaddrsymbol we need to zero GPR0 *)
             Pse_li GPR0 Int.zero ::
             Pe_add16i GPR0 GPR0 (Csymbol_rel_low s ofs) ::
             Pe_add2is GPR0 (Csymbol_rel_high s ofs) ::
             Padd r GPR0 r1 :: k
           else
             Pe_add16i r r1 (Csymbol_low s ofs) ::
             Pe_add2is r (Csymbol_high s ofs) :: k)
  | Osub, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (match r, r1, r2 with
          | Sreg sr, Sreg sr1, Sreg sr2 =>
            if sreg_eq sr sr1 then
              Pse_sub sr sr2 :: k
            else if sreg_eq sr sr2 then
              Pse_subf sr sr1 :: k
            else
              Psubfc r r2 r1 :: k
          | _, _, _ => Psubfc r r2 r1 :: k
         end)
  | Osubimm n, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (loadimm GPR0 n (Psubfc r r1 GPR0 :: k))
  | Omul, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (select_encoding_instr Pse_mullw Pmullw true r r1 r2 k)
  | Omulimm n, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (loadimm GPR0 n (Pmullw r r1 GPR0 :: k))
  | Omulhs, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pmulhw r r1 r2 :: k)
  | Omulhu, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pmulhwu r r1 r2 :: k)
  | Odiv, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pdivw r r1 r2 :: k)
  | Odivu, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pdivwu r r1 r2 :: k)
  | Oand, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (select_encoding_instr Pse_and_ Pand_ true r r1 r2 k)
  | Oandimm n, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (andimm r r1 n k)
  | Oor, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (select_encoding_instr Pse_or Por true r r1 r2 k)
  | Oorimm n, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (orimm r r1 n k)
  | Oxor, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pxor r r1 r2 :: k)
  | Oxorimm n, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (xorimm r r1 n k)
  | Onot, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (Pnor r r1 r1 :: k)
  | Onand, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pnand r r1 r2 :: k)
  | Onor, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pnor r r1 r2 :: k)
  | Onxor, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Peqv r r1 r2 :: k)
  | Oandc, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (select_encoding_instr Pse_andc Pandc false r r1 r2 k)
  | Oorc, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Porc r r1 r2 :: k)
  | Oshl, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (select_encoding_instr Pse_slw Pslw false r r1 r2 k)
  | Oshr, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (select_encoding_instr Pse_sraw Psraw false r r1 r2 k)
  | Oshrimm n, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (shrimm r r1 n k)
  | Oshrximm n, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (shrimm r r1 n (Paddze r r :: k))
  | Oshru, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (select_encoding_instr Pse_srw Psrw false r r1 r2 k)
  | Orolm amount mask, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (rolm r r1 amount mask k)
  | Oroli amount mask, a1 :: a2 :: nil =>
      assertion (mreg_eq a1 res);
      do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pe_rlwimi r r2 amount mask :: k)
  | Ocmp cmp, _ =>
      transl_cond_op cmp args res k
  | Oabsfs, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (Pefsabs r r1 :: k)
  | Oaddfs, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pefsadd r r1 r2 :: k)
  | Odivfs, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pefsdiv r r1 r2 :: k)
  | Omulfs, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pefsmul r r1 r2 :: k)
  | Onegfs, a1 :: nil =>
      do r1 <- ireg_of a1; do r <- ireg_of res;
      OK (Pefsneg r r1 :: k)
  | Osubfs, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
      OK (Pefssub r r1 r2 :: k)
  | Ointofsingle, a1 :: nil =>
     do rd <- ireg_of res;
     do r <- ireg_of a1;
     OK (Pefsctsi rd r :: k)
  | Ointuofsingle, a1 :: nil =>
     do rd <- ireg_of res;
     do r <- ireg_of a1;
     OK (Pefsctui rd r :: k)
  | Osingleofint, a1 :: nil =>
     do rd <- ireg_of res;
     do r <- ireg_of a1;
     OK (Pefscfsi rd r :: k)
  | Osingleofintu, a1 :: nil =>
     do rd <- ireg_of res;
     do r <- ireg_of a1;
     OK (Pefscfui rd r :: k)
  | Osel cmp ty, a1 :: a2 :: args =>
      match preg_of res with
      | IR r1 =>
        do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r <- ireg_of res;
        transl_select_op cmp args r1 r2 r k
      | _ =>
        Error (msg "Asmgen.Osel")
      end
  | _, _ => Error (msg "Asmgen.transl_op")
  end.


(** Translation of memory accesses: loads, and stores. *)

Definition int_temp_for (r: mreg) : ireg :=
  if mreg_eq r R12 then GPR11 else GPR12.

(* Check wether a constant is a valid sd4 immediate. The SD4 field
   in an instruction is an unsigned 4-bit immediate value that is
   zero-extend to 32 bits. Additionally half-word operations are
   shifted by one and word operations are shifted by two bits. *)

(* Type for giving the access size *)
Inductive access_size : Type :=
  | B : access_size  (* Byte *)
  | H : access_size  (* Half Word *)
  | W : access_size. (* Word*)

Definition is_sd4_const (size: access_size) (n: int) :=
  match size with
  | B => Int.eq (Int.shru n (Int.repr 4)) Int.zero
  | H => Int.eq (Int.modu n (Int.repr 2)) Int.zero && Int.eq (Int.shru n (Int.repr 5)) Int.zero
  | W => Int.eq (Int.modu n (Int.repr 4)) Int.zero && Int.eq (Int.shru n (Int.repr 6)) Int.zero
  end.

Definition select_mem_access (size: access_size)
           (instr1 : sreg -> int -> sreg -> instruction)
           (instr2 : ireg -> constant -> ireg -> instruction)
           (rd: ireg) (cst: constant) (base: ireg) :=
  match rd, cst, base with
  | Sreg srd, Cint n, Sreg sbase =>
    if is_sd4_const size n then
      instr1 srd n sbase
    else
      instr2 rd cst base
  | _, _, _ => instr2 rd cst base
  end.

(** VLE Variant of the constructors *)
(** Accessing slots in the stack frame.  *)

Definition accessind {A: Type}
       (instr1: A -> constant -> ireg -> instruction)
       (instr2: A -> ireg -> ireg -> instruction)
       (base: ireg) (ofs: ptrofs) (r: A) (k: code) :=
  let ofs := Ptrofs.to_int ofs in
  if Int.eq (high_s ofs) Int.zero
  then instr1 r (Cint ofs) base :: k
  else loadimm GPR0 ofs (instr2 r base GPR0 :: k).


Definition loadind (base: ireg) (ofs: ptrofs) (ty: typ) (dst: mreg) (k: code) :=
  match ty, preg_of dst with
  | Tint, IR r =>
    let lwz := select_mem_access W Pse_lwz Pe_lwz in
    OK (accessind lwz Plwzx base ofs r k)
  | Tany32, IR r =>
    let lwz_a := select_mem_access W Pse_lwz_a Pe_lwz_a in
    OK (accessind lwz_a Plwzx_a base ofs r k)
  | Tsingle, IR r =>
    let flwz := select_mem_access W Pfse_lwz Pfe_lwz in
    OK (accessind flwz Pflwzx base ofs r k)
  | _, _ => Error (msg "Asmgen.loadind")
  end.

Definition storeind (src: mreg) (base: ireg) (ofs: ptrofs) (ty: typ) (k: code) :=
  match ty, preg_of src with
  | Tint, IR r =>
    let stw := select_mem_access W Pse_stw Pe_stw in
    OK(accessind stw Pstwx base ofs r k)
  | Tany32, IR r =>
    let stw_a := select_mem_access W Pse_stw_a Pe_stw_a in
    OK(accessind stw_a Pstwx_a base ofs r k)
  | Tsingle, IR r =>
    let fstw := select_mem_access W Pfse_stw Pfe_stw in
    OK(accessind fstw Pfstwx base ofs r k)
  | _, _ => Error (msg "Asmgen.storeind")
  end.

(** Translation of memory accesses: loads, and stores. *)

Definition transl_memory_access
     (mk1: constant -> ireg -> instruction)
     (mk2: ireg -> ireg -> instruction)
     (addr: addressing) (args: list mreg)
     (temp: ireg) (k: code) :=
  match addr, args with
  | Aindexed ofs, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (if Int.eq (high_s ofs) Int.zero then
           mk1 (Cint ofs) r1 :: k
          else
           move_rr temp r1 (Pe_add2is temp (Cint (high_s ofs)) ::
                            mk1 (Cint (low_s ofs)) temp :: k))
  | Aindexed2, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (mk2 r1 r2 :: k)
  | Aglobal symb ofs, nil =>
      OK (if symbol_is_small_data symb ofs then
           Pse_li GPR0 Int.zero ::
           Pe_add16i temp GPR0 (Csymbol_sda symb ofs) ::
           mk1 (Cint Int.zero) temp :: k
          else if symbol_is_rel_data symb ofs then
           Pse_li GPR0 Int.zero ::
           Pe_add16i temp GPR0 (Csymbol_rel_low symb ofs) ::
           Pe_add2is temp (Csymbol_rel_high symb ofs) ::
           mk1 (Cint Int.zero) temp :: k
          else
           Pe_lis temp (Csymbol_high symb ofs) ::
           mk1 (Csymbol_low symb ofs) temp :: k)
  | Abased symb ofs, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (if symbol_is_small_data symb ofs then
            Pse_li GPR0 Int.zero ::
            Pe_add16i GPR0 GPR0 (Csymbol_sda symb ofs) ::
            mk2 r1 GPR0 :: k
          else if symbol_is_rel_data symb ofs then
            move_rr temp r1 (Pse_li GPR0 Int.zero ::
                             Pe_add16i GPR0 GPR0 (Csymbol_rel_low symb ofs) ::
                             Pe_add2is GPR0 (Csymbol_rel_high symb ofs) ::
                             mk2 temp GPR0 :: k)
          else
            Pe_add16i temp r1 (Csymbol_low symb ofs) ::
            Pe_add2is temp (Csymbol_high symb ofs) ::
            mk1 (Cint Int.zero) temp :: k)
  | Ainstack ofs, nil =>
      let ofs := Ptrofs.to_int ofs in
      OK (if Int.eq (high_s ofs) Int.zero then
           mk1 (Cint ofs) GPR1 :: k
          else
           Pe_lis GPR0 (Cint (high_s ofs)) ::
           Pe_add16i GPR0 GPR0 (Cint (low_s ofs)) ::
           mk2 GPR1 GPR0 :: k)
  | _, _ =>
      Error(msg "Asmgen.transl_memory_access")
  end.

Definition transl_load (chunk: memory_chunk) (addr: addressing)
                       (args: list mreg) (dst: mreg) (k: code) :=
  match chunk with
  | Mint8signed =>
      do r <- ireg_of dst;
      let lbz := select_mem_access B Pse_lbz Pe_lbz r in
      transl_memory_access lbz (Plbzx r) addr args GPR12 (Pextsb r r :: k)
  | Mint8unsigned =>
      do r <- ireg_of dst;
      let lbz := select_mem_access B Pse_lbz Pe_lbz r in
      transl_memory_access lbz (Plbzx r) addr args GPR12 k
  | Mint16signed =>
      do r <- ireg_of dst;
      transl_memory_access (Pe_lha r) (Plhax r) addr args GPR12 k
  | Mint16unsigned =>
      do r <- ireg_of dst;
      let lhz := select_mem_access H Pse_lhz Pe_lhz r in
      transl_memory_access lhz (Plhzx r) addr args GPR12 k
  | Mint32 =>
      do r <- ireg_of dst;
      let lwz := select_mem_access W Pse_lwz Pe_lwz r in
      transl_memory_access lwz (Plwzx r) addr args GPR12 k
  | Mfloat32 =>
      do r <- ireg_of dst;
      let flwz := select_mem_access W Pfse_lwz Pfe_lwz r in
      transl_memory_access flwz (Pflwzx r) addr args GPR12 k
  | _ =>
      Error (msg "Asmgen.transl_load")
  end.

Definition transl_store (chunk: memory_chunk) (addr: addressing)
                        (args: list mreg) (src: mreg) (k: code) :=
  let temp := int_temp_for src in
  match chunk with
  | Mint8signed | Mint8unsigned =>
      do r <- ireg_of src;
      let stb := select_mem_access B Pse_stb Pe_stb r in
      transl_memory_access stb (Pstbx r) addr args temp k
  | Mint16signed | Mint16unsigned =>
      do r <- ireg_of src;
      let sth := select_mem_access H Pse_sth Pe_sth r in
      transl_memory_access sth (Psthx r) addr args temp k
  | Mint32  =>
      do r <- ireg_of src;
      let stw := select_mem_access W Pse_stw Pe_stw r in
      transl_memory_access stw (Pstwx r) addr args temp k
  | Mfloat32  =>
      do r <- ireg_of src;
      let fstw := select_mem_access W Pfse_stw Pfe_stw r in
      transl_memory_access fstw (Pfstwx r) addr args temp k
  | _ =>
      Error (msg "Asmgen.transl_store")
  end.

(** Function epilogue: reload return address into register LR and
    free the stack frame.  No need to reload the return address if
    this is a tail function. *)

Definition transl_epilogue (f: Mach.function) (k: code) :=
  if is_leaf_function f then
    Pfreeframe f.(fn_stacksize) f.(fn_link_ofs) :: k
  else
    Pe_lwz GPR0 (Cint (Ptrofs.to_int f.(fn_retaddr_ofs))) GPR1 ::
    Pse_mtlr GPR0 ::
    Pfreeframe f.(fn_stacksize) f.(fn_link_ofs) :: k.

(** Translation of a Mach instruction. *)

Definition transl_instr (f: Mach.function) (i: Mach.instruction)
                        (r11_is_parent: bool) (k: code) :=
  match i with
  | Mgetstack ofs ty dst =>
    loadind GPR1 ofs ty dst k
  | Msetstack src ofs ty =>
    storeind src GPR1 ofs ty k
  | Mgetparam ofs ty dst =>
    if r11_is_parent then
      loadind GPR11 ofs ty dst k
    else
      do k1 <- loadind GPR11 ofs ty dst k;
      loadind GPR1 f.(fn_link_ofs) Tint R11 k1
  | Mop op args res =>
    transl_op op args res k
  | Mload chunk addr args dst =>
      transl_load chunk addr args dst k
  | Mstore chunk addr args src =>
      transl_store chunk addr args src k
  | Mcall sig (inl r) =>
      do r1 <- ireg_of r;
      match r1 with
      | Sreg s1 => OK (Pse_mtctr s1 :: Pse_bctrl sig :: k)
      | Areg a1 => OK (Pse_mfar GPR0 a1 :: Pse_mtctr GPR0 :: Pse_bctrl sig :: k)
      end
  | Mcall sig (inr symb) =>
      OK (Pe_bl symb sig :: k)
  | Mtailcall sig (inl r) =>
      do r1 <- ireg_of r;
      match r1 with
      | Sreg s1 => OK (Pse_mtctr s1 :: transl_epilogue f (Pse_bctr sig :: k))
      | Areg a1 => OK (Pse_mfar GPR0 a1 :: Pse_mtctr GPR0 :: transl_epilogue f (Pse_bctr sig :: k))
      end
  | Mtailcall sig (inr symb) =>
      OK (transl_epilogue f (Pe_bs symb sig :: k))
  | Mbuiltin ef args res =>
      OK (Pbuiltin ef (List.map (map_builtin_arg preg_of) args) (map_builtin_res preg_of res) :: k)
  | Mlabel lbl =>
      OK (Plabel lbl :: k)
  | Mgoto lbl =>
      OK (Pe_b lbl :: k)
  | Mcond cond args lbl =>
      let p := crbit_for_cond cond in
      transl_cond cond args
        (if (snd p) then Pbt (fst p) lbl :: k else Pbf (fst p) lbl :: k)
  | Mjumptable arg tbl =>
      do r <- ireg_of arg;
      OK (Pbtbl r tbl :: k)
  | Mreturn =>
      OK (transl_epilogue f (Pse_blr :: k))
  end.

(** Translation of a code sequence *)

Definition it1_is_parent (before: bool) (i: Mach.instruction) : bool :=
  match i with
  | Msetstack src ofs ty => before
  | Mgetparam ofs ty dst => negb (mreg_eq dst R11)
  | Mop Omove args res => before && negb (mreg_eq res R11)
  | _ => false
  end.

(** This is the naive definition that we no longer use because it
  is not tail-recursive.  It is kept as specification. *)

Fixpoint transl_code (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  match il with
  | nil => OK nil
  | i1 :: il' =>
      do k <- transl_code f il' (it1_is_parent it1p i1);
      transl_instr f i1 it1p k
  end.

(** This is an equivalent definition in continuation-passing style
  that runs in constant stack space. *)

Fixpoint transl_code_rec (f: Mach.function) (il: list Mach.instruction)
                         (it1p: bool) (k: code -> res code) :=
  match il with
  | nil => k nil
  | i1 :: il' =>
      transl_code_rec f il' (it1_is_parent it1p i1)
        (fun c1 => do c2 <- transl_instr f i1 it1p c1; k c2)
  end.

Definition transl_code' (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  transl_code_rec f il it1p (fun c => OK c).

(** Translation of a whole function.  Note that we must check
  that the generated code contains less than [2^32] instructions,
  otherwise the offset part of the [PC] code pointer could wrap
  around, leading to incorrect executions. *)

Definition transl_function (f: Mach.function) :=
  do c <- transl_code' f f.(Mach.fn_code) false;
  OK (mkfunction f.(Mach.fn_sig)
       (Pallocframe f.(fn_stacksize) f.(fn_link_ofs) f.(fn_retaddr_ofs) ::
        Pse_mflr GPR0 ::
        Pe_stw GPR0 (Cint (Ptrofs.to_int f.(fn_retaddr_ofs))) GPR1 ::
        Pcfi_rel_offset (Ptrofs.to_int f.(fn_retaddr_ofs)) :: c)).

Definition transf_function (f: Mach.function) : res Asm.function :=
  do tf <- transl_function f;
  if zlt Ptrofs.max_unsigned (list_length_z tf.(fn_code))
  then Error (msg "code size exceeded")
  else OK tf.

Definition transf_fundef (f: Mach.fundef) : res Asm.fundef :=
  transf_partial_fundef transf_function f.

Definition transf_program (p: Mach.program) : res Asm.program :=
  transform_partial_program transf_fundef p.
