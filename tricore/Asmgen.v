(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Xavier Leroy, INRIA Paris-Rocquencourt                     *)
(*                                                                     *)
(*  Copyright Institut National de Recherche en Informatique et en     *)
(*  Automatique.  All rights reserved.  This file is distributed       *)
(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
(*                                                                     *)
(* *********************************************************************)

(** Translation from Mach to TriCore. *)

Require Archi.
Require Import Coqlib Errors.
Require Import AST Integers Floats Memdata.
Require Import Op Locations Mach Asm.

Local Open Scope string_scope.
Local Open Scope error_monad_scope.

(** The code generation functions take advantage of several
  characteristics of the [Mach] code generated by earlier passes of the
  compiler, mostly that argument and result registers are of the correct
  types.  These properties are true by construction, but it's easier to
  recheck them during code generation and fail if they do not hold. *)

(** Extracting integer or float registers. *)

Definition ireg_of (r: mreg) : res dreg :=
  match preg_of r with DREG mr => OK mr | _ => Error(msg "Asmgen.ireg_of") end.

Definition freg_of (r: mreg) : res dreg :=
  match preg_of r with DREG mr => OK mr | _ => Error(msg "Asmgen.freg_of") end.

(** Integer constant functions *)

Program Definition mk_sconst_n (n : { n: Z | 0 < n < 31 }) x : signed_const_n n :=
  {| s_amount := Int.sign_ext n x |}.
Next Obligation.
  split; try lia.
  assert (N_range: two_p (n-1) < Int.half_modulus).
  { change (Int.half_modulus) with (two_p 31). apply two_p_monotone_strict. lia. }
  exploit (Int.sign_ext_range n x). unfold Int.zwordsize ; simpl; lia.
  intros.
  unfold is_in_signed_range. apply andb_true_iff. split; apply zlt_true.
  rewrite Int.signed_repr. lia.
  unfold Int.min_signed, Int.max_signed. lia.
  rewrite Int.signed_repr. lia.
  unfold Int.min_signed, Int.max_signed. lia.
Qed.

Program Definition mk_sconst4 n : sconst4 := mk_sconst_n 4 n.
Next Obligation. lia. Qed.

Program Definition mk_sconst9 n : sconst9 := mk_sconst_n 9 n.
Next Obligation. lia. Qed.

Program Definition mk_sconst16 n : sconst16 := mk_sconst_n 16 n.
Next Obligation. lia. Qed.

Program Definition mk_uconst_n (n : { n: Z | 0 < n < 32 }) x : unsigned_const_n n :=
  {| u_amount := Int.zero_ext n x |}.
Next Obligation.
  split. unfold Int.ltu. apply zlt_true. rewrite Int.unsigned_repr.
  apply (Int.zero_ext_range n x). unfold Int.zwordsize; simpl; lia.
  unfold Int.max_unsigned. simpl. change (4294967295) with ((two_p 32) - 1).
  assert (two_p n <= two_p 31).
  assert (0 < n < 31 \/ n = 31). lia.
  destruct H.
  exploit (two_p_monotone_strict n 31). lia. lia.
  rewrite H. lia.
  split. exploit (two_p_strict n); lia.
  change 32 with (Z.succ 31).
  rewrite ZArith.Zpower.two_p_S. assert (two_p 31 > 1). compute. reflexivity.
  lia. lia.
  unfold Int.zwordsize; simpl; lia.
Qed.

Program Definition mk_uconst4 n: uconst4 := mk_uconst_n 4 n.
Next Obligation. lia. Qed.

Program Definition mk_uconst5 n: uconst5 := mk_uconst_n 5 n.
Next Obligation. lia. Qed.

Program Definition mk_uconst8 n : uconst8 := mk_uconst_n 8 n.
Next Obligation. lia. Qed.

Program Definition mk_uconst9 n : uconst9 := mk_uconst_n 9 n.
Next Obligation. lia. Qed.

Program Definition mk_uconst16 n : uconst16 := mk_uconst_n 16 n.
Next Obligation. lia. Qed.

Definition get_sconst4 n : option sconst4 :=
  if is_in_signed_range 4 n then
    Some (mk_sconst4 n)
  else
    None.

Definition get_uconst4 n : option uconst4 :=
  if Int.ltu n (Int.repr 16) then
    Some (mk_uconst4 n)
  else
    None.

Definition get_sconst9 n : option sconst9 :=
  if is_in_signed_range 9 n then
    Some (mk_sconst9 n)
  else
    None.

Definition get_sconst16 n : option sconst16 :=
  if is_in_signed_range 16 n then
    Some (mk_sconst16 n)
  else
    None.

Definition get_uconst9 n : option uconst9 :=
  if Int.ltu n (Int.repr (two_p 9)) then
    Some (mk_uconst9 n)
  else
    None.

Definition move_rr (rd r: dreg) (k: code) :=
  if dreg_eq rd r then
    k
  else
    Pmov rd r :: k.

Definition bit0 : uconst5 := mk_uconst5 Int.zero.
Definition bit1 : uconst5 := mk_uconst5 Int.one.
Definition bit2 : uconst5 := mk_uconst5 (Int.repr 2).

(** Decomposition of integer constants.  As noted in file [Asm],
  immediate arguments to TriCore instructions must fit into 16 bits,
  and are interpreted after zero extension, sign extension, or
  left shift by 16 bits, depending on the instruction.  Integer
  constants that do not fit must be synthesized using two
  processor instructions.  The following functions decompose
  arbitrary 32-bit integers into two 16-bit halves (high and low
  halves).  They satisfy the following properties:
- [low_u n] is an unsigned 16-bit integer;
- [low_s n] is a signed 16-bit integer;
- [(high_u n) << 16 | low_u n] equals [n];
- [(high_s n) << 16 + low_s n] equals [n].
*)

Definition low_s (n: int) := mk_sconst16 n.
Definition high_s (n: int) := mk_uconst16 (Int.shru (Int.sub n (low_s n)) (Int.repr 16)).

(** Smart constructors for arithmetic operations involving
  a 32-bit integer constant. Depending on whether the
  constant fits in the immediate offsets or not, one
  or several instructions are generated as required
  to perform the operation and prepended to the
  given instruction sequence [k]. *)

Definition loadimm (r: dreg) (n: int) (k: code) :=
  if Int.eq (high_s n) Int.zero then
    Pmovi r (low_s n) :: k
  else if Int.eq (low_s n) Int.zero then
    Pmovh r (high_s n) :: k
  else
    Pmovh r (high_s n) ::
    Paddi r r (low_s n) :: k.

Definition select_encoding_instr
           (instr1: dreg -> dreg -> instruction)
           (instr2: dreg -> dreg -> dreg -> instruction)
           (commut: bool) (rd r1 r2: dreg) (k: code) :=
  if dreg_eq rd r1 then
    instr1 rd r2 :: k
  else if commut && dreg_eq rd r2 then
    instr1 rd r1 :: k
  else
    instr2 rd r1 r2 ::k.

Definition add (rd r1 r2: dreg) (k: code) :=
  select_encoding_instr Padd_rr Padd true rd r1 r2 k.

Definition sub (rd r1 r2: dreg) (k: code) :=
  select_encoding_instr Psub_rr Psub false rd r1 r2 k.

Definition mul (rd r1 r2: dreg) (k: code) :=
  select_encoding_instr Pmul_rr Pmul true rd r1 r2 k.

Definition and (rd r1 r2: dreg) (k: code) :=
  select_encoding_instr Pand_rr Pand true rd r1 r2 k.

Definition or (rd r1 r2: dreg) (k: code) :=
  select_encoding_instr Por_rr Por true rd r1 r2 k.

Definition xor (rd r1 r2: dreg) (k: code) :=
  select_encoding_instr Pxor_rr Pxor true rd r1 r2 k.

(* Smart selection for unsigned 9 bit constants *)
Definition op_sc9
           (op1: sconst9 -> instruction)
           (op2: dreg -> code -> code)
           (n: int) (k: code) :=
  match get_sconst9 n with
  | Some imm => op1 imm :: k
  | None => loadimm TMP n (op2 TMP k)
  end.

Definition addimm_gen {T : Type}
  (add_low: T -> T -> sconst16 -> instruction)
  (add_high: T -> T -> uconst16  -> instruction)
  (rd r: T) (n: int) (k: code) :=
  if Int.eq (high_s n) Int.zero then
    add_low rd r (low_s n) :: k
  else if Int.eq (low_s n) Int.zero then
    add_high rd r (high_s n) :: k
  else
    add_high rd r (high_s n) :: add_low rd rd (low_s n) :: k.

Definition addimm (rd r: dreg) (n: int) (k: code) :=
  if dreg_eq rd r && is_in_signed_range 4 n then
    Padd_sc4 rd (mk_sconst4 n) :: k
  else addimm_gen Paddi Paddih rd r n k.

Definition rsubimm (rd r: dreg) (n: int) (k: code) :=
  if dreg_eq rd r && Int.eq n Int.zero then
    Prsub_r rd :: k
  else
    op_sc9 (Prsub rd r) (fun r' => sub rd r' r) n k.

Definition mulimm (rd r : dreg) (n:int) (k: code) :=
  op_sc9 (Pmul_sc9 rd r) (mul rd r) n k.

Definition slimm (rd r: dreg) (n: int) (k: code) :=
  if dreg_eq rd r && Int.ltu n (Int.repr 8) then
    Psh_sc4 rd (mk_sconst4 n) :: k
  else
    Psh_sc9 rd r (mk_sconst9 n) :: k.

Definition lsrimm (rd r: dreg) (n: amount32) (k: code) :=
  if dreg_eq rd r && (Int.ltu n (Int.repr 9)) then
    Psh_sc4 rd (mk_sconst4 (Int.neg n)) :: k
  else
    Psh_sc9 rd r (mk_sconst9 (Int.neg n)) :: k.

Definition asrimm (rd r: dreg) (n: amount32) (k: code) :=
  if dreg_eq rd r && (Int.ltu n (Int.repr 9)) then
    Psha_sc4 rd (mk_sconst4 (Int.neg n)) :: k
  else
    Psha_sc9 rd r (mk_sconst9 (Int.neg n)) :: k.

Definition maddimm (rd r1 r2: dreg) (n:int) (k:code) :=
  op_sc9 (Pmadd_sc9 rd r1 r2) (fun r3 k => Pmadd rd r1 r2 r3 :: k) n k.

Definition msubimm (rd r1 r2: dreg) (n:int) (k:code) :=
  op_sc9 (Pmsub_sc9 rd r1 r2) (fun r3 k => Pmsub rd r1 r2 r3 :: k) n k.

(* Smart selection for unsigned 9 byte constants *)
Definition op_uc9
           (op1: uconst9 -> instruction)
           (op2: dreg -> code -> code)
           (n: int) (k: code) :=
  match get_uconst9 n with
  | Some imm => op1 imm :: k
  | None => loadimm TMP n (op2 TMP k)
  end.

(* Smart selection for unsigned 9 byte constants with the
   additional case that an instruction exists which negates
   the constant *)
Definition op_uc9_not
           (op1: uconst9 -> instruction)
           (op1n: uconst9 -> instruction)
           (op2: dreg -> code -> code)
           (n: int) (k:code) :=
  match get_uconst9 (Int.not n) with
  | Some imm => op1n imm :: k
  | None => op_uc9 op1 op2 n k
  end.

Definition andimm (rd r: dreg) (n: int) (k: code) :=
  if dreg_eq rd r && dreg_eq rd D15 && Int.ltu n (Int.repr (two_p 8)) then
    Pand_d15uc8 (mk_uconst8 n) :: k
  else
    op_uc9_not (Pand_ruc9 rd r) (Pandn_uc9 rd r) (and rd r) n k.

Definition nandimm (rd r: dreg) (n: int) (k: code) :=
  op_uc9 (Pnand_uc9 rd r) (fun r2 k => Pnand rd r r2 :: k) n k.

Definition orimm (rd r: dreg) (n: int) (k: code) :=
  if dreg_eq rd r && dreg_eq rd D15 && Int.ltu n (Int.repr (two_p 8)) then
    Por_d15uc8 (mk_uconst8 n) :: k
  else
    op_uc9_not (Por_ruc9 rd r) (Porn_uc9 rd r) (or rd r) n k.

Definition norimm (rd r: dreg) (n: int) (k: code) :=
  op_uc9 (Pnor_uc9 rd r) (fun r2 k => Pnor rd r r2 :: k) n k.

Definition xorimm (rd r: dreg) (n: int) (k: code) :=
  op_uc9 (Pxor_ruc9 rd r) (xor rd r) n k.

Definition xnorimm (rd r: dreg) (n: int) (k:code) :=
  op_uc9 (Pxnor_uc9 rd r) (fun r2 k => Pxnor rd r r2 :: k) n k.

(** Translation of conditional branches. *)

Definition transl_cbranch_int32s (cmp: comparison) (r1 r2: dreg) (lbl: label) :=
  match cmp with
  | Ceq => Pjeq r1 r2 lbl
  | Cne => Pjne r1 r2 lbl
  | Clt => Pjlt r1 r2 lbl
  | Cle => Pjge r2 r1 lbl
  | Cgt => Pjlt r2 r1 lbl
  | Cge => Pjge r1 r2 lbl
  end.

Definition transl_cbranch_int32s_imm (cmp: comparison) (n: int) (r: dreg) (lbl: label) (k: code) :=
  let def := loadimm TMP n (transl_cbranch_int32s cmp r TMP lbl :: k) in
  match cmp with
  | Ceq =>
      match get_sconst4 n with
      | Some imm => Pjeq_sc4 r imm lbl :: k
      | None => def
      end
  | Cne =>
      match get_sconst4 n with
      | Some imm => Pjne_sc4 r imm lbl :: k
      | None => def
      end
  | Clt =>
      match get_sconst4 n with
      | Some imm => Pjlt_sc4 r imm lbl :: k
      | None => def
      end
  | Cge =>
      match get_sconst4 n with
      | Some imm => Pjge_sc4 r imm lbl :: k
      | None => def
      end
  | Cle =>
      if (Int.lt (Int.repr (-10)) n && Int.lt n (Int.repr 7)) then
        Pjlt_sc4 r (mk_sconst4 (Int.add n Int.one)) lbl :: k
      else
        def
  | Cgt =>
      if (Int.lt (Int.repr (-10)) n && Int.lt n (Int.repr 7)) then
        Pjge_sc4 r (mk_sconst4 (Int.add n Int.one)) lbl :: k
      else
        def
  end.

Definition transl_cbranch_int32u (cmp: comparison) (r1 r2: dreg) (lbl: label) :=
  match cmp with
  | Ceq => Pjeq r1 r2 lbl
  | Cne => Pjne r1 r2 lbl
  | Clt => Pjltu r1 r2 lbl
  | Cle => Pjgeu r2 r1 lbl
  | Cgt => Pjltu r2 r1 lbl
  | Cge => Pjgeu r1 r2 lbl
  end.

Definition transl_cbranch_int32u_imm (cmp: comparison) (n: int) (r: dreg) (lbl: label) (k: code) :=
  let def := loadimm TMP n (transl_cbranch_int32u cmp r TMP lbl :: k) in
  match cmp with
  | Ceq =>
      match get_sconst4 n with
      | Some imm => Pjeq_sc4 r imm lbl :: k
      | None => def
      end
  | Cne =>
      match get_sconst4 n with
      | Some imm => Pjne_sc4 r imm lbl :: k
      | None => def
      end
  | Clt =>
      match get_uconst4 n with
      | Some imm => Pjltu_sc4 r imm lbl :: k
      | None => def
      end
  | Cge =>
      match get_uconst4 n with
      | Some imm => Pjgeu_sc4 r imm lbl :: k
      | None => def
      end
  | Cle =>
      if Int.eq n Int.zero then
        Pjeq_sc4 r (mk_sconst4 Int.zero) lbl :: k
      else if Int.ltu n (Int.repr 15) then
        Pjltu_sc4 r (mk_uconst4 (Int.add n Int.one)) lbl :: k
      else
        def
  | Cgt =>
      if Int.ltu n (Int.repr 15) then
        Pjgeu_sc4 r (mk_uconst4 (Int.add n Int.one)) lbl :: k
      else
        def
  end.

Definition bit_of_cond_single (cmp: comparison) :=
  match cmp with
  | Ceq => (bit1, true)
  | Cne => (bit1, false)
  | Clt => (bit0, true)
  | Cle => (bit0, true)
  | Cgt => (bit2, true)
  | Cge => (bit0, true)
  end.

Definition transl_cond_single_branch (cmp: comparison) (rd r1 r2: dreg) (k: code) :=
  match cmp with
  | Cle =>
      Pcmpf rd r1 r2 :: Por_t rd rd bit1 rd bit0 :: k
  | Cge =>
      Pcmpf rd r1 r2 :: Por_t rd rd bit1 rd bit2 :: k
  | _ => Pcmpf rd r1 r2 :: k
  end.

Definition transl_cbranch
           (cond: condition) (args: list mreg) (lbl: label) (k: code) :=
  match cond, args with
  | Ccomp c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cbranch_int32s c r1 r2 lbl :: k)
  | Ccompu c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cbranch_int32u c r1 r2 lbl :: k)
  | Ccompimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_cbranch_int32s_imm c n r1 lbl k)
  | Ccompuimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_cbranch_int32u_imm c n r1 lbl k)
  | Ccompfs c, f1 :: f2 :: nil =>
      do r1 <- ireg_of f1; do r2 <- ireg_of f2;
      let (bit, normal) := bit_of_cond_single c in
      let insn := if normal then Pjnz_t TMP bit lbl else Pjz_t TMP bit lbl in
      OK (transl_cond_single_branch c TMP r1 r2 (insn :: k))
  | Cnotcompfs c, f1 :: f2 :: nil =>
      do r1 <- ireg_of f1; do r2 <- ireg_of f2;
      let (bit, normal) := bit_of_cond_single c in
      let insn := if normal then Pjz_t TMP bit lbl else Pjnz_t TMP bit lbl in
      OK (transl_cond_single_branch c TMP r1 r2 (insn :: k))
  | Ccompf c, _ =>
    Error (msg "Double comparison not supported")
  | Cnotcompf c, _ =>
    Error (msg "Double comparison not supported")
  | _, _ =>
      Error(msg "Asmgen.transl_cond_branch")
  end.

Definition transl_cond_int32s (cmp: comparison) (rd r1 r2: dreg) :=
  match cmp with
  | Ceq => Peq rd r1 r2
  | Cne => Pne rd r1 r2
  | Clt => Plt rd r1 r2
  | Cle => Pge rd r2 r1
  | Cgt => Plt rd r2 r1
  | Cge => Pge rd r1 r2
  end.

Definition transl_condimm_int32s (cmp: comparison) (rd r: dreg) (n: int) (k: code) :=
  let def := loadimm TMP n (transl_cond_int32s cmp rd r TMP :: k) in
  match cmp with
  | Ceq =>
      match get_sconst9 n with
      | Some imm => Peq_sc9 rd r imm :: k
      | None => def
      end
  | Cne =>
      match get_sconst9 n with
      | Some imm => Pne_sc9 rd r imm :: k
      | None => def
      end
  | Clt =>
      match get_sconst9 n with
      | Some imm => Plt_sc9 rd r imm :: k
      | None => def
      end
  | Cge =>
      match get_sconst9 n with
      | Some imm => Pge_sc9 rd r imm :: k
      | None => def
      end
  | Cle =>
      if (Int.lt (Int.repr (-258)) n && Int.lt n (Int.repr 255)) then
        Plt_sc9 rd r (mk_sconst9 (Int.add n Int.one)) :: k
      else
        def
  | Cgt =>
      if (Int.lt (Int.repr (-258)) n && Int.lt n (Int.repr 255)) then
        Pge_sc9 rd r (mk_sconst9 (Int.add n Int.one)) :: k
      else
        def
  end.

Definition transl_cond_int32u (cmp: comparison) (rd r1 r2: dreg) :=
  match cmp with
  | Ceq => Peq rd r1 r2
  | Cne => Pne rd r1 r2
  | Clt => Pltu rd r1 r2
  | Cle => Pgeu rd r2 r1
  | Cgt => Pltu rd r2 r1
  | Cge => Pgeu rd r1 r2
  end.

Definition transl_condimm_int32u (cmp: comparison) (rd r: dreg) (n: int) (k: code) :=
  let def := loadimm TMP n (transl_cond_int32u cmp rd r TMP :: k) in
  match cmp with
  | Ceq =>
      match get_sconst9 n with
      | Some imm => Peq_sc9 rd r imm :: k
      | None => def
      end
  | Cne =>
      match get_sconst9 n with
      | Some imm => Pne_sc9 rd r imm :: k
      | None => def
      end
  | Clt =>
      match get_uconst9 n with
      | Some imm => Pltu_uc9 rd r imm :: k
      | None => def
      end
  | Cge =>
      match get_uconst9 n with
      | Some imm => Pgeu_uc9 rd r imm :: k
      | None => def
      end
  | Cle =>
      if Int.eq n Int.zero then
        Peq_sc9 rd r (mk_sconst9 Int.zero) :: k
      else if Int.ltu n (Int.repr 511) then
        Pltu_uc9 rd r (mk_uconst9 (Int.add n Int.one)) :: k
      else
        def
  | Cgt =>
      if Int.ltu n (Int.repr 511) then
        Pgeu_uc9 rd r (mk_uconst9 (Int.add n (Int.one))) :: k
      else
        def
  end.

Definition bits_of_cond_single (cmp: comparison) :=
  match cmp with
  | Ceq => (bit1, bit1, true)
  | Cne => (bit1, bit1, false)
  | Clt => (bit0, bit0, true)
  | Cle => (bit0, bit1, true)
  | Cgt => (bit2, bit2, true)
  | Cge => (bit1, bit2, true)
  end.

Definition transl_cond_single_op (invert: bool) (cmp: comparison) (rd r1 r2: dreg) (k: code) :=
  let '(bit_1, bit_2, normal) := (bits_of_cond_single cmp) in
  let insn := if xorb normal invert then Por_t rd rd bit_1 rd bit_2 else Pnor_t rd rd bit_1 rd bit_2 in
  Pcmpf rd r1 r2 :: insn :: k.

Definition transl_cond_op
           (cond: condition) (rd: dreg) (args: list mreg)  (k: code) :=
  match cond, args with
  | Ccomp c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cond_int32s c rd r1 r2 :: k)
  | Ccompu c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cond_int32u c rd r1 r2 :: k)
  | Ccompimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_condimm_int32s c rd r1 n k)
  | Ccompuimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_condimm_int32u c rd r1 n k)
  | Ccompfs c, f1 :: f2 :: nil =>
      do r1 <- ireg_of f1; do r2 <- ireg_of f2;
      OK (transl_cond_single_op false c rd r1 r2 k)
  | Cnotcompfs c, f1 :: f2 :: nil =>
      do r1 <- ireg_of f1; do r2 <- ireg_of f2;
      OK (transl_cond_single_op true c rd r1 r2 k)
  | Ccompf c, _ =>
    Error (msg "Double comparison not supported")
  | Cnotcompf c, _ =>
    Error (msg "Double comparison not supported")
  | _, _ =>
      Error(msg "Asmgen.transl_cond_branch")
  end.

Definition transl_op
           (op: operation) (args: list mreg) (res: mreg) (k: code) :=
   match op, args with
   | Omove, a1 :: nil =>
       match preg_of res, preg_of a1 with
       | DREG res, DREG a1 => OK (Pmov res a1 :: k)
       | AREG res, AREG a1 => OK (Pmov_aa res a1 :: k)
       | AREG res, DREG a1 => OK (Pmov_a res a1 :: k)
       | DREG res, AREG a1 => OK (Pmov_d res a1 :: k)
       | _, _ => Error (msg "Asmgen.Omove")
       end
   | Ointconst n, nil =>
       do rd <- ireg_of res;
       OK (loadimm rd n k)
   | Osingleconst n, nil =>
       do rd <- ireg_of res;
       OK (Ploadsi rd n :: k)
   | Oaddrsymbol s ofs, nil =>
       do rd <- ireg_of res;
       OK (Pmovh_s rd s ofs :: Paddi_ls rd rd s ofs :: k)
   | Oaddrstack ofs, nil =>
       do rd <- ireg_of res;
       OK (Pmov_d rd SP :: addimm rd rd (Ptrofs.to_int ofs) k)
   | Oadd, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (add rd r1 r2 k)
   | Oaddimm imm, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (addimm rd r1 imm k)
   | Osub, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
      OK (sub rd r1 r2 k)
   | Orsubimm imm, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (rsubimm rd r1 imm k)
   | Oneg, a1 :: nil =>
       do r <- ireg_of a1; do rd <- ireg_of res;
       OK (move_rr rd r (Prsub_r rd :: k))
   | Omul, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (mul rd r1 r2 k)
   | Omulimm imm, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (mulimm rd r1 imm k)
   | Omulhs, a1 :: a2 :: nil =>
       assertion (mreg_eq res R5);
       do r1 <- ireg_of a1; do r2 <- ireg_of a2;
       OK (Pmul_e r1 r2 :: k)
   | Omulhu, a1 :: a2 :: nil =>
       assertion (mreg_eq res R5);
       do r1 <- ireg_of a1; do r2 <- ireg_of a2;
       OK (Pmulu r1 r2 :: k)
   | Omadd, a1 :: a2 :: a3 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r3 <- ireg_of a3; do rd <- ireg_of res;
       OK (Pmadd rd r1 r2 r3 :: k)
   | Omaddimm imm, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (maddimm rd r1 r2 imm k)
   | Omsub, a1 :: a2 :: a3 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do r3 <- ireg_of a3; do rd <- ireg_of res;
       OK (Pmsub rd r1 r2 r3 :: k)
   | Omsubimm imm, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (msubimm rd r1 r2 imm k)
   | Odiv, a1 :: a2 :: nil =>
       assertion (mreg_eq res R4);
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pdiv r1 r2 :: k)
   | Odivu, a1 :: a2 :: nil =>
       assertion (mreg_eq res R4);
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pdivu r1 r2 :: k)
   | Omod, a1 :: a2 :: nil =>
       assertion (mreg_eq res R5);
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pdiv r1 r2 :: k)
   | Omodu, a1 :: a2 :: nil =>
       assertion (mreg_eq res R5);
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pdivu r1 r2 :: k)
   | Onot, a1 :: nil =>
       do r <- ireg_of a1; do rd <- ireg_of res;
       OK (move_rr rd r (Pnot rd :: k))
   | Oand, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (and rd r1 r2 k)
   | Oandimm n, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (andimm rd r1 n k)
   | Oandn, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pandn rd r1 r2 :: k)
   | Onand, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pnand rd r1 r2 :: k)
   | Onandimm n, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (nandimm rd r1 n k)
   | Oor, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (or rd r1 r2 k)
   | Oorimm n, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (orimm rd r1 n k)
   | Oorn, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Porn rd r1 r2 :: k)
   | Onor, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pnor rd r1 r2 :: k)
   | Onorimm n, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (norimm rd r1 n k)
   | Oxor, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (xor rd r1 r2 k)
   | Oxorimm n, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (xorimm rd r1 n k)
   | Oxnor, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pxnor rd r1 r2 :: k)
   | Oxnorimm n, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (xnorimm rd r1 n k)
   | Osl, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Psh rd r1 r2 :: k)
   | Oslimm n, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (slimm rd r1 n k)
   | Oasr, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Prsub D0 r2 (mk_sconst9 Int.zero) :: Psha rd r1 D0 :: k)
   | Oasrimm n, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (asrimm rd r1 n k)
   | Olsr, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Prsub D0 r2 (mk_sconst9 Int.zero) :: Psh rd r1 D0 :: k)
   | Olsrimm n, a1 :: nil =>
       do r1 <- ireg_of a1; do rd <- ireg_of res;
       OK (lsrimm rd r1 n k)
   | Oshrximm n, a1 :: nil =>
       do rd <- ireg_of res; do rs <- ireg_of a1;
       OK(if Int.eq n Int.zero then Pmov rd rs :: k else
          Psha_sc9 TMP rs (mk_sconst9 (Int.neg (Int.repr 31))) ::
          Psh_sc9 TMP TMP (mk_sconst9 (Int.neg (Int.sub Int.iwordsize n))) ::
          Padd TMP rs TMP ::
          Psha_sc9 rd TMP (mk_sconst9 (Int.neg n)) :: k)
   | Oextr pos width, a :: nil =>
       do r <- ireg_of a; do rd <- ireg_of res;
       OK (Pextr rd r (mk_uconst5 pos) (mk_uconst5 width) :: k)
   | Oextru pos width, a :: nil =>
       do r <- ireg_of a; do rd <- ireg_of res;
       OK (Pextru rd r (mk_uconst5 pos) (mk_uconst5 width) :: k)
   | Oinsert pos width, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pinsert rd r1 r2 (mk_uconst5 pos) (mk_uconst5 width) :: k)
   | Osel cmp _, a1 :: a2 :: args =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       (transl_cond_op cmp TMP args (Psel rd TMP r1 r2 :: k))
   | Ocmp cmp, _ =>
      do rd <- ireg_of res;
      transl_cond_op cmp rd args k
   | Onegfs, a :: nil =>
       do r <- ireg_of a; do rd <- ireg_of res;
       OK (Pnegf rd r :: k)
   | Oabsfs, a :: nil =>
       do r <- ireg_of a; do rd <- ireg_of res;
       OK (Pabsf rd r :: k)
   | Oaddfs, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Paddf rd r1 r2 :: k)
   | Osubfs, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Psubf rd r1 r2 :: k)
   | Omulfs, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pmulf rd r1 r2 :: k)
   | Odivfs, a1 :: a2 :: nil =>
       do r1 <- ireg_of a1; do r2 <- ireg_of a2; do rd <- ireg_of res;
       OK (Pdivf rd r1 r2 :: k)
   | Ointofsingle, a :: nil =>
       do r <- ireg_of a; do rd <- ireg_of res;
       OK (Pftoiz rd r :: k)
   | Ointuofsingle, a :: nil =>
       do r <- ireg_of a; do rd <- ireg_of res;
       OK (Pftouz rd r :: k)
   | Osingleofint, a :: nil =>
       do r <- ireg_of a; do rd <- ireg_of res;
       OK (Pitof rd r :: k)
   | Osingleofintu, a :: nil =>
       do r <- ireg_of a; do rd <- ireg_of res;
       OK (Putof rd r :: k)
   | Ofloatconst n, _ =>
     Error (msg "Floatconst for double is not supported")
   | Onegf, _ =>
     Error (msg "Neg for double is not supported")
   | Oabsf, _ =>
     Error (msg "Absf for double is not supported")
   | Oaddf, _ =>
     Error (msg "Addf for double is not supported")
   | Osubf, _ =>
     Error (msg "Subf for double is not supported")
   | Omulf, _ =>
     Error (msg "Mulf for double is not supported")
   | Odivf, _ =>
     Error (msg "Divf for double is not supported")
   | Osingleoffloat, _ =>
     Error (msg "Single to dobule conversion is not supported")
   | Ofloatofsingle, _ =>
     Error (msg "Double to single conversion is not supported")
   | Ointoffloat, _ =>
     Error (msg "Double to signed int conversion is not supported")
   | Ointuoffloat, _ =>
     Error (msg "Double to unsigned int conversion is not supported")
   | Ofloatofint, _ =>
     Error (msg "Signed int to double conversion is not supported")
   | Ofloatofintu, _ =>
     Error (msg "Unsigned int to double conversion is not supported")
   | _,_ => Error(msg "Asmgen.transl_op")
   end.

(** Accessing data in the stack frame. *)

Definition indexed_memory_access
           (mk1_instr: areg -> instruction)
           (mk2_instr: areg -> sconst16 -> instruction)
           (base: areg) (ofs: ptrofs) (k: code) :=
  if Ptrofs.eq ofs Ptrofs.zero then
    mk1_instr base :: k
  else
    match get_sconst16 (Ptrofs.to_int ofs) with
    | Some ofs' =>
        mk2_instr base ofs' :: k
    | None =>
        let ofs := Ptrofs.to_int ofs in
        Paddih_a TMPA base (high_s ofs) ::
        mk2_instr TMPA (low_s ofs):: k
    end.

Definition loadind (base: areg) (ofs: ptrofs) (ty: typ) (dst: mreg) (k: code) : res code :=
  match ty, preg_of dst with
  | Tint,    DREG rd => OK (indexed_memory_access (Pldw_rr rd) (Pldw rd) base ofs k)
  | Tsingle, DREG rd => OK (indexed_memory_access (Pfldw_rr rd) (Pfldw rd) base ofs k)
  | Tany32,  DREG rd => OK (indexed_memory_access (Pldw_a_rr rd) (Pldw_a rd) base ofs k)
  | Tint,    AREG rd => OK (indexed_memory_access (Plda_rr rd) (Plda rd) base ofs k)
  | _, _           => Error (msg "Asmgen.loadind")
  end.


Definition storeind (src: mreg) (base: areg) (ofs: ptrofs) (ty: typ) (k: code) : res code :=
  match ty, preg_of src with
  | Tint,    DREG src => OK (indexed_memory_access (Pstw_rr src) (Pstw src) base ofs k)
  | Tsingle, DREG src => OK (indexed_memory_access (Pfstw_rr src) (Pfstw src) base ofs k)
  | Tany32,  DREG src => OK (indexed_memory_access (Pstw_a_rr src) (Pstw_a src) base ofs k)
  | Tint,    AREG src => OK (indexed_memory_access (Psta_rr src) (Psta src) base ofs k)
  | _, _           => Error (msg "Asmgen.storeind")
  end.

Definition loadind2 (base: dreg) (ofs: ptrofs) (ty: typ) (dst: mreg) (k: code) :=
  do c <- loadind TMPA ofs ty dst k;
  OK (Pmov_a TMPA base :: c).

Definition loadind_ptr2 (base: areg) (ofs: ptrofs) (dst: dreg) (k: code) :=
  indexed_memory_access (Pldw_rr dst) (Pldw dst) base ofs k.

Definition loadind_ptr (base: areg) (ofs: ptrofs) (dst: areg) (k: code) :=
  indexed_memory_access (Plda_rr dst) (Plda dst) base ofs k.

Definition storeind_ptr (src: areg) (base: areg) (ofs: ptrofs) (k: code) :=
  indexed_memory_access (Psta_rr src) (Psta src) base ofs k.

(** Translation of memory accesses: loads, and stores. *)

Definition lea rd id k :=
  Pmovh_as rd id :: Plea_s rd rd id :: k.

Definition transl_memory_access
     (mk1: areg -> instruction)
     (mk2: areg -> sconst16 -> instruction)
     (addr: addressing) (args: list mreg) (k: code)  : res code:=
  match addr, args with
  | Ainstack ofs, nil =>
      OK (indexed_memory_access mk1 mk2 SP ofs k)
  | Aindexed ofs, a1 :: nil =>
      do rs <- ireg_of a1;
      OK (Pmov_a TMPA rs :: indexed_memory_access mk1 mk2 TMPA (Ptrofs.of_int ofs) k)
  | Aglobal id ofs, nil =>
      OK (lea TMPA id (indexed_memory_access mk1 mk2 TMPA ofs k))
  | _, _ =>
      Error(msg "Asmgen.transl_memory_access")
  end.

Definition transl_load (chunk: memory_chunk) (addr: addressing)
           (args: list mreg) (dst: mreg) (k: code) :=
  match chunk with
  | Mint8signed =>
      do r <- ireg_of dst;
      transl_memory_access (Pldb_rr r) (Pldb r)  addr args k
  | Mint8unsigned =>
      do r <- ireg_of dst;
      transl_memory_access (Pldbu_rr r) (Pldbu r) addr args k
  | Mint16signed =>
      do r <- ireg_of dst;
      transl_memory_access (Pldh_rr r) (Pldh r)  addr args k
  | Mint16unsigned =>
      do r <- ireg_of dst;
      transl_memory_access (Pldhu_rr r) (Pldhu r) addr args k
  | Mint32 =>
      do r <- ireg_of dst;
      transl_memory_access (Pldw_rr r) (Pldw r)  addr args k
  | Mfloat32 =>
      do r <- ireg_of dst;
      transl_memory_access (Pfldw_rr r) (Pfldw r) addr args k
  | _ =>
      Error (msg "Asmgen.transl_load")
  end.

Definition transl_store (chunk: memory_chunk) (addr: addressing)
           (args: list mreg) (src: mreg) (k: code) :=
  match chunk with
  | Mint8signed | Mint8unsigned =>
      do r <- ireg_of src;
      transl_memory_access (Pstb_rr r) (Pstb r) addr args k
  | Mint16signed | Mint16unsigned =>
      do r <- ireg_of src;
      transl_memory_access (Psth_rr r) (Psth r) addr args k
  | Mint32 =>
      do r <- ireg_of src;
      transl_memory_access (Pstw_rr r) (Pstw r)  addr args k
  | Mfloat32 =>
      do r <- freg_of src;
      transl_memory_access (Pfstw_rr r) (Pfstw r) addr args k
  | _ =>
      Error (msg "Asmgen.transl_store")
  end.


(** Function epilogue *)

Definition make_epilogue (f: Mach.function) (k: code) :=
  loadind_ptr SP f.(fn_retaddr_ofs) RA
    (Pfreeframe f.(fn_stacksize) f.(fn_link_ofs) :: k).

Definition make_epilogue' (f: Mach.function) (r: dreg) (k: code) :=
  loadind_ptr SP f.(fn_retaddr_ofs) RA
    (Pfreeframe f.(fn_stacksize) f.(fn_link_ofs) :: Pmov_a TMPA r :: k).

(** Translation of a Mach instruction. *)

Definition transl_instr (f: Mach.function) (i: Mach.instruction)
           (a12_is_parent: bool) (k: code) :=
  match i with
  | Mgetstack ofs ty dst =>
      loadind SP ofs ty dst k
  | Msetstack src ofs ty =>
      storeind src SP ofs ty k
  | Mgetparam ofs ty dst =>
  (* load via the frame pointer if it is valid *)
      do c <- loadind A12 ofs ty dst k;
      OK (if a12_is_parent then c else loadind_ptr SP f.(fn_link_ofs) A12 c)
  | Mop op args res =>
      transl_op op args res k
  | Mload chunk addr args dst =>
      transl_load chunk addr args dst k
  | Mstore chunk addr args src =>
      transl_store chunk addr args src k
  | Mcall sig (inl r) =>
      do r1 <- ireg_of r; OK (Pmov_a TMPA r1 :: Pcalli TMPA sig :: k)
  | Mcall sig (inr symb) =>
      OK (Pcall symb sig :: k)
  | Mtailcall sig (inl r) =>
      do r1 <- ireg_of r;
      OK (make_epilogue' f r1 (Pji TMPA sig :: k))
  | Mtailcall sig (inr symb) =>
      OK (make_epilogue f (Pj_s symb sig :: k))
  | Mbuiltin ef args res =>
      OK (Pbuiltin ef (List.map (map_builtin_arg preg_of) args) (map_builtin_res preg_of res) :: k)
  | Mlabel lbl =>
      OK (Plabel lbl :: k)
  | Mgoto lbl =>
      OK (Pj_l lbl :: k)
  | Mcond cond args lbl =>
      transl_cbranch cond args lbl k
  | Mjumptable arg tbl =>
      do r <- ireg_of arg;
      OK (Pbtbl r tbl :: k)
  | Mreturn =>
      OK (make_epilogue f (Pret :: k))
  end.

(** Translation of a code sequence *)

Definition it1_is_parent (before: bool) (i: Mach.instruction) : bool :=
  match i with
  | Msetstack src ofs ty => before
  | Mgetparam ofs ty dst => negb (mreg_eq dst P12)
  | Mop op args res => before && negb (mreg_eq res P12)
  | _ => false
  end.

(** This is the naive definition that we no longer use because it
  is not tail-recursive.  It is kept as specification. *)

Fixpoint transl_code (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  match il with
  | nil => OK nil
  | i1 :: il' =>
      do k <- transl_code f il' (it1_is_parent it1p i1);
      transl_instr f i1 it1p k
  end.

(** This is an equivalent definition in continuation-passing style
  that runs in constant stack space. *)

Fixpoint transl_code_rec (f: Mach.function) (il: list Mach.instruction)
                         (it1p: bool) (k: code -> res code) :=
  match il with
  | nil => k nil
  | i1 :: il' =>
      transl_code_rec f il' (it1_is_parent it1p i1)
        (fun c1 => do c2 <- transl_instr f i1 it1p c1; k c2)
  end.

Definition transl_code' (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  transl_code_rec f il it1p (fun c => OK c).

(** Translation of a whole function.  Note that we must check
  that the generated code contains less than [2^32] instructions,
  otherwise the offset part of the [PC] code pointer could wrap
  around, leading to incorrect executions. *)

Definition transl_function (f: Mach.function) :=
  do c <- transl_code' f f.(Mach.fn_code) true;
  OK (mkfunction f.(Mach.fn_sig)
        (Pallocframe f.(fn_stacksize) f.(fn_link_ofs) ::
         storeind_ptr RA SP f.(fn_retaddr_ofs) c)).

Definition transf_function (f: Mach.function) : res Asm.function :=
  do tf <- transl_function f;
  if zlt Ptrofs.max_unsigned (list_length_z tf.(fn_code))
  then Error (msg "code size exceeded")
  else OK tf.

Definition transf_fundef (f: Mach.fundef) : res Asm.fundef :=
  transf_partial_fundef transf_function f.

Definition transf_program (p: Mach.program) : res Asm.program :=
  transform_partial_program transf_fundef p.
