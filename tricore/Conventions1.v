(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Xavier Leroy, INRIA Paris-Rocquencourt                     *)
(*                                                                     *)
(*  Copyright Institut National de Recherche en Informatique et en     *)
(*  Automatique.  All rights reserved.  This file is distributed       *)
(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
(*                                                                     *)
(* *********************************************************************)

(** Function calling conventions and other conventions regarding the use of
    machine registers and stack slots. *)

Require Import Coqlib.
Require Import Decidableplus.
Require Import AST.
Require Import Events.
Require Import Locations.
Require Archi.

(** * Classification of machine registers *)

(* TODO fill out the file *)

Definition is_callee_save (r: mreg): bool :=
  match r with
  | R1 => true
  | _ => false
  end.

Definition destroyed_at_call :=
  List.filter (fun r => negb (is_callee_save r)) all_mregs.

Definition callee_save_type (r: mreg): typ :=
  match r with
  | ErrorReg => Tany64
  | _ => Tany32
  end.

Definition is_float_reg (r: mreg): bool := false.

Definition int_caller_save_regs : list mreg :=
     R2 :: R3  :: R4  :: R5  :: R6  :: R7  :: R8  :: R9  :: R10
  :: R11 :: R12 :: R13 :: R14 :: R15 :: nil.

Definition float_caller_save_regs : list mreg :=
  nil.

Definition int_callee_save_regs : list mreg :=
  nil.

Definition float_callee_save_regs : list mreg :=
  nil.

Definition dummy_int_reg := R4.     (**r Used in [Coloring]. *)
Definition dummy_float_reg := R5.   (**r Used in [Coloring]. *)

(** How to use registers for register allocation.
    We favor the use of caller-save registers, using callee-save registers
    only when no caller-save is available. *)

Record alloc_regs := mk_alloc_regs {
  preferred_int_regs: list mreg;
  remaining_int_regs: list mreg;
  preferred_float_regs: list mreg;
  remaining_float_regs: list mreg
}.

Definition allocatable_registers (_: unit) :=
  {| preferred_int_regs := int_caller_save_regs;
     remaining_int_regs := int_callee_save_regs;
     preferred_float_regs := float_caller_save_regs;
     remaining_float_regs := float_callee_save_regs |}.

(** * Function calling conventions *)

(** The functions in this section determine the locations (machine registers
  and stack slots) used to communicate arguments and results between the
  caller and the callee during function calls.  These locations are functions
  of the signature of the function and of the call instruction.
  Agreement between the caller and the callee on the locations to use
  is guaranteed by our dynamic semantics for Cminor and RTL, which demand
  that the signature of the call instruction is identical to that of the
  called function.

  Calling conventions are largely arbitrary: they must respect the properties
  proved in this section (such as no overlapping between the locations
  of function arguments), but this leaves much liberty in choosing actual
  locations.  To ensure binary interoperability of code generated by our
  compiler with libraries compiled by another PowerPC compiler, we
  implement the standard conventions defined in the PowerPC/EABI
  application binary interface. *)

(** ** Location of function result *)

(** The result value of a function is passed back to the caller in
  registers [R2] or [R2, R3], depending on the type of the returned value.
  We treat a function without result as a function with one integer result.
  TODO Pointer values are returned in A2
 *)

Definition loc_result (s: signature) : rpair mreg :=
  match s.(sig_res) with
  | Tint8signed | Tint8unsigned | Tint16signed | Tint16unsigned | Tvoid| Tint | Tany32 | Tsingle => One R2
  | Trptr => One P2
  | Tfloat | Tany64 => One ErrorReg
  | Tlong => Twolong R3 R2
  end.

(** The result registers have types compatible with that given in the signature. *)

Lemma loc_result_type:
  forall sig,
  subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true.
Proof.
  intros. unfold loc_result, mreg_type, proj_sig_res.
  destruct (sig_res sig) eqn:?; simpl; auto.
  destruct t; auto.
Qed.

(** The result locations are caller-save registers *)

Lemma loc_result_caller_save:
  forall (s: signature),
  forall_rpair (fun r => is_callee_save r = false) (loc_result s).
Proof.
  intros. unfold loc_result, is_callee_save;
  destruct (sig_res s), (proj_sig_res s); try  destruct t; simpl; auto.
Qed.

(** If the result is in a pair of registers, those registers are distinct and have type [Tint] at least. *)

Lemma loc_result_pair:
  forall sg,
  match loc_result sg with
  | One _ => True
  | Twolong r1 r2 =>
        r1 <> r2 /\ proj_sig_res sg = Tlong
     /\ subtype Tint (mreg_type r1) = true /\ subtype Tint (mreg_type r2) = true
     /\ Archi.ptr64 = false
  end.
Proof.
  intros; unfold loc_result, mreg_type, proj_sig_res.
  destruct (sig_res sg) eqn:?; try destruct t; simpl; auto.
  split; auto. congruence.
Qed.


(** The location of the result depends only on the result part of the signature *)

Lemma loc_result_exten:
  forall s1 s2, simpl_rettype_match true s1.(sig_res) s2.(sig_res) -> loc_result s1 = loc_result s2.
Proof.
  intros. unfold loc_result, proj_sig_res.
  destruct (sig_res s1), (sig_res s2); inv H; auto.
Qed.

(** ** Location of function arguments *)

(**
   - None pointer arguments are passed in registers [D4...D7]
   - Pointer arguemnets are passed in registers [A4...A7]

  Arguments that are larger than 64 bits are passed via stack.
  64 bit arguements are passed in aligned registers, e.g. D4,
  D5 or D6 and D7. If D5 is not used first due to a 64 bit
  argument then it can be used for a later 32 bit argument.
  For example WORD, DWORD, WORD are passed D4, D6/D7 and D5.

  Arguments on the stack are either WORD or DWORD aligned.
  Non fixed varargs are also passed on the stack.
*)

Definition param_regs :=
  R4 :: R5 :: R6 :: R7 :: nil.

Definition ptr_param_regs :=
  P4 :: P5 :: P6 :: P7 :: nil.

(** [lookup_register l r5_skipped fixed r] returns  the register at position r
    from the param registers list, if [r5_skipped] is true the register R5 was
    skipped due to the constraint that 64 bit arguments should be passed in
    either R4/R5 or R6/R7. *)
Definition lookup_register l (r5_skipped: bool)  r : option mreg :=
  if r5_skipped then
    list_nth_z l 1
  else
    list_nth_z l r.

Definition stack_arg (ty: argtype) (r5_skipped : bool) (r p ofs: Z)
                     (rec: bool -> Z -> Z -> Z -> list (rpair loc)) :=
  let arg :=
    if typ_eq (proj_argtype ty) Tlong then
      Twolong (S Outgoing (ofs + 1) Tint) (S Outgoing ofs Tint)
    else
      One (S Outgoing ofs (proj_argtype ty)) in
  arg :: rec r5_skipped r p (ofs + typesize (proj_argtype ty)).

Fixpoint loc_arguments_stack (tyl: list argtype) (ofs: Z) {struct tyl} : list (rpair loc) :=
  match tyl with
  | nil => nil
  | ty :: tys =>
      stack_arg ty false 0 0 ofs (fun r5 r p ofs => loc_arguments_stack tys ofs)
  end.

Definition simple_arg (ty: argtype) (r5_skipped: bool) (r p ofs: Z)
                      (rec: bool -> Z -> Z -> Z -> list (rpair loc)) :=
  match lookup_register param_regs r5_skipped r  with
  | None =>
      stack_arg ty false r p ofs rec
  | Some ireg =>
      One (R ireg) :: rec false (r + 1) p ofs
  end.

Definition ptr_arg (r5_skipped : bool) (r p ofs: Z)
                   (rec: bool -> Z -> Z -> Z -> list (rpair loc)) :=
  match list_nth_z ptr_param_regs p with
  | None =>
      stack_arg Taptr r5_skipped r (p + 1) ofs rec
  | Some areg =>
      One (R areg) :: rec r5_skipped r (p + 1) ofs
  end.

Definition long_arg (r5_skipped: bool) (r p ofs: Z)
                    (rec: bool -> Z -> Z -> Z -> list (rpair loc)) :=
  let r' := align r 2 in
  match list_nth_z param_regs r',  list_nth_z param_regs (r' + 1) with
  | Some r1, Some r2 =>
      Twolong (R r2) (R r1) :: rec (zeq r 1) (r' + 2) p ofs
  | _, _ =>
      stack_arg Tlong r5_skipped r p ofs rec
  end.

(** [loc_arguments_rec tyl r5_skipped fixed r ofs] computes the location of the current
    argument based upon the type in [tyl]. [r] is the next free register and [ofs] is
    the stack offset. [fixed] is the number of non vararg arguments that are not used.
    [r5_skipped] is only true if we are in the case that R5 is skipped due to a 64 bit
    argument, then the next 32 bit argument is placed R5. *)
Fixpoint loc_arguments_rec
  (tyl: list argtype) (fixed: Z) (r5_skipped: bool) (r p ofs: Z) {struct tyl} : list (rpair loc) :=
  match tyl with
  | nil => nil
  | ty :: tys =>
      if (zle fixed 0) then loc_arguments_stack tyl ofs else
        match ty with
        | Taptr  => ptr_arg r5_skipped r p ofs (loc_arguments_rec tys (fixed - 1))
        | (Tint | Tany32 | Tsingle) as ty => simple_arg ty r5_skipped r p ofs (loc_arguments_rec tys (fixed - 1))
        | (Tfloat | Tany64) as ty =>
            stack_arg ty r5_skipped r p ofs (loc_arguments_rec tys (fixed - 1))
        | Tlong => long_arg r5_skipped r p ofs (loc_arguments_rec tys (fixed - 1))
        end
  end.

(** Number of fixed arguments for a function with signature [s]. *)

Definition fixed_arguments (s: signature) : Z :=
  match s.(sig_cc).(cc_vararg) with
  | Some n => n
  | None => list_length_z s.(sig_args)
  end.

(** [loc_arguments s] returns the list of locations where to store arguments
  when calling a function with signature [s].  *)

Definition loc_arguments (s: signature) : list (rpair loc) :=
  loc_arguments_rec s.(sig_args) (fixed_arguments s) false 0 0 0.


(** Argument locations are either non-temporary registers or [Outgoing]
  stack slots at nonnegative offsets. *)


Definition loc_argument_acceptable (l: loc) : Prop :=
  match l with
  | R r => is_callee_save r = false
  | S Outgoing ofs ty => ofs >= 0 /\ (typealign ty | ofs)
  | _ => False
  end.

Remark lookup_register_in:
  forall l r5_skipped r x,
    lookup_register l r5_skipped r = Some x -> In x l.
Proof.
  unfold lookup_register; intros.
  destruct r5_skipped; try discriminate H.
  eapply list_nth_z_in; eauto.
  eapply list_nth_z_in; eauto.
Qed.

Remark loc_arguments_rec_acceptable:
  forall tyl r5_skipped fixed r ofs rp p,
  ofs >= 0 ->
  In p (loc_arguments_rec tyl fixed r5_skipped r rp ofs) ->
  forall_rpair loc_argument_acceptable p.
Proof.
  set (OK := fun (l: list (rpair loc)) =>
               forall p, In p l -> forall_rpair loc_argument_acceptable p).
  set (OKF := fun (f: bool -> Z ->  Z -> Z -> list (rpair loc)) =>
                forall r5 r p ofs, ofs >= 0 -> OK (f r5 r p ofs)).
  assert (CSI: forall r, In r param_regs -> is_callee_save r = false).
  { decide_goal. }
  assert (CSP: forall r, In r ptr_param_regs -> is_callee_save r = false).
  { decide_goal. }
  assert (STK: forall tyl ofs,
               ofs >= 0 -> OK (loc_arguments_stack tyl ofs)).
  { induction tyl as [ | ty tyl]; intros ofs OO; red; simpl; intros.
  - contradiction.
  - destruct (typ_eq (proj_argtype ty)).
    + destruct H.
      * subst p. split; split; try lia; simpl; apply Z.divide_1_l.
      * rewrite e in H. apply IHtyl with (ofs := ofs + typesize Tlong).
        simpl. lia. auto.
    + destruct H.
      * subst p. split. lia. destruct (proj_argtype); try contradiction; apply Z.divide_1_l.
      * apply IHtyl with (ofs := ofs + typesize (proj_argtype ty)).
        destruct (proj_argtype); simpl; lia. auto.
  }
  assert (A : forall ty r5 r p ofs f,
           OKF f -> ofs >= 0 -> OK (stack_arg ty r5 r p ofs f)).
  { intros until f; intros OF OO; red; unfold stack_arg; intros.
    destruct H.
    - subst p0; simpl; auto. destruct typ_eq; auto.
      split; split; try lia; simpl; apply Z.divide_1_l.
      split. lia. destruct proj_argtype; try contradiction; apply Z.divide_1_l.
    - eapply OF; [|eauto]. destruct proj_argtype; simpl; lia.
  }
  assert (B: forall ty r5 r p ofs f,
           OKF f -> ofs >= 0 -> OK (simple_arg ty r5 r p ofs f)).
  { intros until f; intros OF OO; red; unfold simple_arg; intros.
    destruct (lookup_register param_regs r5 r) as [r'|] eqn:NTH; [destruct H|].
    - subst p0; simpl. apply CSI. eapply lookup_register_in; eauto.
    - eapply OF; eauto.
    - eapply A; eauto.
  }
  assert (C: forall r5 r p ofs f,
         OKF f -> ofs >= 0 -> OK (ptr_arg r5 r p ofs f)).
  { intros until f; intros OF OO; red; unfold ptr_arg; intros.
    destruct (list_nth_z ptr_param_regs p) as [p'|] eqn:NTH; [destruct H|].
    - subst p0; simpl. apply CSP. eapply list_nth_z_in; eauto.
    - eapply OF; eauto.
    - eapply A; eauto.
  }
  assert (D: forall r5 r p ofs f,
         OKF f -> ofs >= 0 -> OK (long_arg r5 r p ofs f)).
  { intros until f; intros OF OO; red; unfold long_arg; intros.
    set (r' := align r 2) in *.
    destruct (list_nth_z param_regs r') as [r1|] eqn:NTH1; destruct (list_nth_z param_regs (r' + 1)) as [r2|] eqn:NTH2.
    - destruct H. subst p0; simpl. split; apply CSI; eapply list_nth_z_in; eauto.
      eapply OF; eauto.
    - destruct H. subst p0; simpl. split; split; try lia; apply Z.divide_1_l.
      simpl in H. eapply OF with (ofs := (ofs + 2)); eauto. lia.
    - eapply A; eauto.
    - eapply A; eauto.
  }
  cut (forall tyl fixed r5 r p ofs, ofs >= 0 -> OK (loc_arguments_rec tyl r5 fixed r p ofs)).
  unfold OK. eauto.
  induction tyl as [| ty1 tyl]; intros until ofs; intros OO; simpl.
  - red; simpl; tauto.
  - destruct (zle r5 0).
    + apply (STK (ty1 :: tyl)); auto.
    + unfold OKF in *; destruct ty1; [destruct t|]; eauto.
Qed.

Lemma loc_arguments_acceptable:
  forall (s: signature) (p: rpair loc),
  In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p.
Proof.
  unfold loc_arguments; intros.
  eapply loc_arguments_rec_acceptable; eauto. lia.
Qed.

Global Hint Resolve loc_arguments_acceptable: locs.

Lemma loc_arguments_main:
  loc_arguments signature_main = nil.
Proof.
  reflexivity.
Qed.

(** ** Normalization of function results *)

(** No normalization needed. *)

Definition return_value_needs_normalization (t: rettype) := false.
Definition parameter_needs_normalization (t: rettype) := false.
Definition ptr_return_ptr_reg := true.

Global Opaque is_callee_save.
