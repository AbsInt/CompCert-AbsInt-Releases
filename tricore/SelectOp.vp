(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Bernhard Schommer, AbsInt Angewandte Informatik GmbH       *)
(*                                                                     *)
(*  AbsInt Angewandte Informatik GmbH. All rights reserved. This file  *)
(*  is distributed under the terms of the INRIA Non-Commercial         *)
(*  License Agreement.                                                 *)
(*                                                                     *)
(* *********************************************************************)

(** Instruction selection for operators *)

(** The instruction selection pass recognizes opportunities for using
  combined arithmetic and logical operations and addressing modes
  offered by the target processor.

  This file defines functions for building CminorSel expressions and
  statements, especially expressions consisting of operator
  applications.  These functions examine their arguments to choose
  cheaper forms of operators whenever possible.

  For instance, [add e1 e2] will return a CminorSel expression semantically
  equivalent to [Eop Oadd (e1 ::: e2 ::: Enil)], but will use a
  [Oaddimm] operator if one of the arguments is an integer constant,
  or suppress the addition altogether if one of the arguments is the
  null integer.  In passing, we perform operator reassociation
  ([(e + c1) * c2] becomes [(e * c2) + (c1 * c2)]) and a small amount
  of constant propagation.

  On top of the "smart constructor" functions defined below,
  module [Selection] implements the actual instruction selection pass.
*)

Require Import Coqlib.
Require Import Compopts.
Require Import AST Integers Floats Builtins.
Require Import Op CminorSel.
Require Archi.

Local Open Scope cminorsel_scope.

(** ** Constants **)

Definition addrsymbol (id: ident) (ofs: ptrofs) :=
  Eop (Oaddrsymbol id ofs) Enil.

Definition addrstack (ofs: ptrofs) :=
  Eop (Oaddrstack ofs) Enil.

(** ** Integer addition *)

Nondetfunction addimm (n: int) (e: expr) :=
  if Int.eq n Int.zero then e else
  match e with
  | Eop (Ointconst m) Enil       => Eop (Ointconst(Int.add n m)) Enil
  | Eop (Oaddrsymbol s m) Enil   => Eop (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int n) m)) Enil
  | Eop (Oaddrstack m) Enil      => Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int n) m)) Enil
  | Eop (Oaddimm m) (t ::: Enil) => Eop (Oaddimm(Int.add n m)) (t ::: Enil)
  | _                            => Eop (Oaddimm n) (e ::: Enil)
  end.

Nondetfunction add (e1: expr) (e2: expr) :=
  match e1, e2 with
  | Eop (Ointconst n1) Enil, t2 =>
      addimm n1 t2
  | t1, Eop (Ointconst n2) Enil =>
      addimm n2 t1
  | Eop (Oaddimm n1) (t1:::Enil), Eop (Oaddimm n2) (t2:::Enil) =>
      addimm (Int.add n1 n2) (Eop Oadd (t1:::t2:::Enil))
  | Eop (Oaddimm n1) (t1:::Enil), Eop (Oaddrstack n2) Enil =>
      Eop Oadd (Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int n1) n2)) Enil ::: t1 ::: Enil)
  | Eop (Oaddrstack n1) Enil, Eop (Oaddimm n2) (t2:::Enil) =>
      Eop Oadd (Eop (Oaddrstack (Ptrofs.add n1 (Ptrofs.of_int n2))) Enil ::: t2 ::: Enil)
  | Eop (Oaddimm n1) (t1:::Enil), t2 =>
      addimm n1 (Eop Oadd (t1:::t2:::Enil))
  | t1, Eop (Oaddimm n2) (t2:::Enil) =>
      addimm n2 (Eop Oadd (t1:::t2:::Enil))
  | t1, Eop Omul (t2:::t3:::Enil) =>
      Eop Omadd (t1:::t2:::t3:::Enil)
  | Eop Omul (t1:::t2:::Enil), t3 =>
      Eop Omadd (t3:::t1:::t2:::Enil)
  | t1, Eop (Omulimm n) (t2:::Enil) =>
      Eop (Omaddimm n) (t1:::t2:::Enil)
  | Eop (Omulimm n) (t1:::Enil), t2 =>
      Eop (Omaddimm n) (t2:::t1:::Enil)
  | _, _ =>
      Eop Oadd (e1:::e2:::Enil)
  end.

(** ** Integer and pointer subtraction *)

Nondetfunction subimm (n1: int) (e: expr) :=
  match e with
  | Eop (Ointconst n2) Enil =>
      Eop (Ointconst (Int.sub n1 n2)) Enil
  | Eop (Oaddimm n2) (t2:::Enil) =>
      Eop (Orsubimm (Int.sub n1 n2)) (t2 ::: Enil)
  | _ =>
      Eop (Orsubimm n1) (e ::: Enil)
  end.

Nondetfunction sub (e1: expr) (e2: expr) :=
  match e1, e2 with
  | t1, Eop (Ointconst n2) Enil =>
      addimm (Int.neg n2) t1
  | Eop (Ointconst n1) Enil, t2 =>
      subimm n1 t2
  | Eop (Oaddimm n1) (t1:::Enil), Eop (Oaddimm n2) (t2:::Enil) =>
      addimm (Int.sub n1 n2) (Eop Osub (t1:::t2:::Enil))
  | Eop (Oaddimm n1) (t1:::Enil), t2 =>
      addimm n1 (Eop Osub (t1:::t2:::Enil))
  | t1, Eop (Oaddimm n2) (t2:::Enil) =>
      addimm (Int.neg n2) (Eop Osub (t1:::t2:::Enil))
  | t1, Eop Omul (t2:::t3:::Enil) =>
      Eop Omsub (t1:::t2:::t3:::Enil)
  | t1, Eop (Omulimm n) (t2:::Enil) =>
      Eop (Omsubimm n) (t1:::t2:::Enil)
  | _, _ =>
      Eop Osub (e1:::e2:::Enil)
  end.

Definition negint (e: expr) := Eop Oneg (e:::Enil).

(** ** Immediate shift left *)

Nondetfunction shlimm (e1: expr) (n: int) :=
  if Int.eq n Int.zero then
    e1
  else if negb (Int.ltu n Int.iwordsize) then
    Eop Osl (e1 ::: Eop (Ointconst n) Enil ::: Enil)
  else match e1 with
   | Eop (Ointconst n1) Enil =>
       Eop (Ointconst (Int.shl n1 n)) Enil
   | _ =>
      Eop (Oslimm (mk_amount32 n)) (e1 ::: Enil)
   end.

(** ** Immediate shift right (arithmetic) *)

Nondetfunction shrimm (e1: expr) (n: int) :=
  if Int.eq n Int.zero then
    e1
  else if negb (Int.ltu n Int.iwordsize) then
    Eop Oasr (e1 ::: Eop (Ointconst n) Enil ::: Enil)
  else match e1 with
   | Eop (Ointconst n1) Enil =>
       Eop (Ointconst (Int.shr n1 n)) Enil
   | Eop (Oslimm n1) (e2 ::: Enil) =>
       let w := Int.sub Int.iwordsize n  in
       let p := Int.sub n n1 in
       if Int.ltu p Int.iwordsize && Int.ltu w Int.iwordsize then
          Eop (Oextr (mk_amount32 p) (mk_amount32 w)) (e2 ::: Enil)
       else
          Eop (Oasrimm (mk_amount32 n)) (e1 ::: Enil)
   | _ =>
       Eop (Oasrimm (mk_amount32 n)) (e1 ::: Enil)
   end.

(** ** Immediate shift right (logical) *)

Nondetfunction shruimm (e1: expr) (n: int) :=
  if Int.eq n Int.zero then
    e1
  else if negb (Int.ltu n Int.iwordsize) then
    Eop Olsr (e1 ::: Eop (Ointconst n) Enil ::: Enil)
   else match e1 with
    | Eop (Ointconst n1) Enil =>
        Eop (Ointconst (Int.shru n1 n)) Enil
    | Eop (Oslimm n1) (e2 ::: Enil) =>
       let w := Int.sub Int.iwordsize n  in
       let p := Int.sub n n1 in
       if Int.ltu p Int.iwordsize && Int.ltu w Int.iwordsize then
          Eop (Oextru (mk_amount32 p) (mk_amount32 w)) (e2 ::: Enil)
       else
          Eop (Olsrimm (mk_amount32 n)) (e1 ::: Enil)
    | _ =>
       Eop (Olsrimm (mk_amount32 n)) (e1 ::: Enil)
    end.

(** ** Integer multiply *)

Definition mulimm_base (n1: int) (e2: expr) :=
  match Int.one_bits n1 with
  | i :: nil =>
      shlimm e2 i
  | i :: j :: nil =>
      Elet e2 (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))
  | _ =>
      Eop (Omulimm n1) (e2:::Enil)
  end.

Nondetfunction mulimm (n1: int) (e2: expr) :=
  if Int.eq n1 Int.zero then Eop (Ointconst Int.zero) Enil
  else if Int.eq n1 Int.one then e2
  else match e2 with
  | Eop (Ointconst n2) Enil => Eop (Ointconst(Int.mul n1 n2)) Enil
  | Eop (Oaddimm n2) (t2:::Enil) => addimm (Int.mul n1 n2) (mulimm_base n1 t2)
  | _ => mulimm_base n1 e2
  end.

Nondetfunction mul (e1: expr) (e2: expr) :=
  match e1, e2 with
  | Eop (Ointconst n1) Enil, t2 => mulimm n1 t2
  | t1, Eop (Ointconst n2) Enil => mulimm n2 t1
  | _, _ => Eop Omul (e1:::e2:::Enil)
  end.

Definition mulhs (e1: expr) (e2: expr) := Eop Omulhs (e1 ::: e2 ::: Enil).
Definition mulhu (e1: expr) (e2: expr) := Eop Omulhu (e1 ::: e2 ::: Enil).

(** ** Bitwise not *)

Nondetfunction notint (e: expr) :=
  match e with
  | Eop (Ointconst n) Enil => Eop (Ointconst (Int.not n)) Enil
  | Eop Onot (t1:::Enil) => t1
  | Eop Oand ((Eop (Ointconst n) Enil):::t1:::Enil) => Eop (Onandimm n) (t1:::Enil)
  | Eop Oand (t1:::(Eop (Ointconst n) Enil):::Enil) => Eop (Onandimm n) (t1:::Enil)
  | Eop Oand (t1:::t2:::Enil) => Eop Onand (t1:::t2:::Enil)
  | Eop Oor (t1:::t2:::Enil) => Eop Onor (t1:::t2:::Enil)
  | Eop Oxor (t1:::t2:::Enil) => Eop Oxnor (t1:::t2:::Enil)
  | Eop Onand (t1:::t2:::Enil) => Eop Oand (t1:::t2:::Enil)
  | Eop Oandn (t1:::t2:::Enil) =>
    Eop Oorn (t2:::t1:::Enil)
  | Eop Oorn (t1:::t2:::Enil) =>
    Eop Oandn (t2:::t1:::Enil)
  | Eop Onor (t1:::t2:::Enil) => Eop Oor (t1:::t2:::Enil)
  | Eop Oxnor (t1:::t2:::Enil) => Eop Oxor (t1:::t2:::Enil)
  | Eop (Oxorimm n) (t1:::Enil) => Eop (Oxorimm (Int.not n)) (t1:::Enil)
  | _ => Eop Onot (e:::Enil)
  end.

(** ** Bitwise and, or, xor *)

Nondetfunction andimm (n1: int) (e2: expr) :=
  if Int.eq n1 Int.zero then Eop (Ointconst Int.zero) Enil
  else if Int.eq n1 Int.mone then e2
  else match e2 with
  | Eop (Ointconst n2) Enil => Eop (Ointconst (Int.and n1 n2)) Enil
  | Eop (Oandimm n2) (t2:::Enil) => Eop (Oandimm (Int.and n1 n2)) (t2:::Enil)
  | _ => Eop (Oandimm n1) (e2:::Enil)
  end.

Nondetfunction and (e1: expr) (e2: expr) :=
  match e1, e2 with
  | Eop (Ointconst n1) Enil, t2 => andimm n1 t2
  | t1, Eop (Ointconst n2) Enil => andimm n2 t1
  | Eop Onot (t1:::Enil), Eop Onot (t2:::Enil) => Eop Onor (t1:::t2:::Enil)
  | Eop Onot (t1:::Enil), t2 => Eop Oandn (t2:::t1:::Enil)
  | t1, Eop Onot (t2:::Enil) => Eop Oandn (t1:::t2:::Enil)
  | _, _ => Eop Oand (e1:::e2:::Enil)
  end.

Nondetfunction orimm (n1: int) (e2: expr) :=
  if Int.eq n1 Int.zero then e2
  else if Int.eq n1 Int.mone then Eop (Ointconst Int.mone) Enil
  else match e2 with
  | Eop (Ointconst n2) Enil =>
    Eop (Ointconst (Int.or n1 n2)) Enil
  | Eop (Oorimm n2) (t2:::Enil) =>
    Eop (Oorimm (Int.or n1 n2)) (t2:::Enil)
  | _ => Eop (Oorimm n1) (e2:::Enil)
  end.

Definition same_expr_pure (e1 e2: expr) :=
  match e1, e2 with
  | Evar v1, Evar v2 => if ident_eq v1 v2 then true else false
  | _, _ => false
  end.

(* We can use the Oinsert instruction for bitfield write access *)

Definition is_mask (mask : int) (amount : amount32) :=
  let mask' := Int.shr mask amount in
  match Int.is_power2 (Int.add mask' Int.one) with
  | Some width =>
    if Int.eq (Int.shl (Int.sub (Int.repr (two_p (Int.unsigned width))) Int.one) amount) mask
    then Some width
    else None
  | None => None
  end.

Definition insert_mask (mask : int) (amount: amount32) (t1 t2 def: expr) :=
  match is_mask mask amount with
  | Some width =>
    match t2 with
    | Eop (Ointconst n) _ =>
      Eop (Oinsertimm n amount (mk_amount32 width)) (t1:::Enil)
    | _ => Eop (Oinsert amount (mk_amount32 width)) (t1:::t2:::Enil)
    end
  | None => def
  end.

Definition insert_mask_nmask (mask nmask: int) (amount: amount32) (t1 t2 def: expr) :=
  if (Int.eq nmask (Int.not mask))
  then insert_mask mask amount t1 t2 def
  else def.

Definition insert_mask_mask (mask1 mask2: int) (amount: amount32) (t1 t2 def: expr) :=
  if (Int.eq mask1 mask2)
  then insert_mask mask1 amount t1 t2 def
  else def.

Nondetfunction insert (e1: expr) (e2: expr) :=
  match e1, e2 with
  | Eop Oand ((Eop (Oslimm amount) (t2:::Enil)):::(Eop (Ointconst mask) Enil):::Enil), Eop Oand (t1:::(Eop (Ointconst nmask) Enil):::Enil) =>
    insert_mask_nmask mask nmask amount t1 t2 (Eop Oor (e1:::e2:::Enil))
  | Eop Oand (t1:::(Eop (Ointconst nmask) Enil):::Enil), Eop Oand ((Eop (Oslimm amount) (t2:::Enil)):::(Eop (Ointconst mask) Enil):::Enil) =>
    insert_mask_nmask mask nmask amount t1 t2 (Eop Oor (e1:::e2:::Enil))
  | Eop Oandn (t1:::(Eop (Ointconst mask1) Enil):::Enil), Eop Oand ((Eop (Oslimm amount) (t2:::Enil)):::(Eop (Ointconst mask2) Enil):::Enil) =>
    insert_mask_mask mask1 mask2 amount t1 t2 (Eop Oor (e1:::e2:::Enil))
  | Eop Oand ((Eop (Oslimm amount) (t2:::Enil)):::(Eop (Ointconst mask2) Enil):::Enil), Eop Oandn (t1:::(Eop (Ointconst mask1) Enil):::Enil) =>
    insert_mask_mask mask1 mask2 amount t1 t2 (Eop Oor (e1:::e2:::Enil))
  | _, _ => Eop Oor (e1:::e2:::Enil)
  end.

Nondetfunction or (e1: expr) (e2: expr) :=
  match e1, e2 with
  | Eop (Ointconst n1) Enil, t2 => orimm n1 t2
  | t1, Eop (Ointconst n2) Enil => orimm n2 t1
  | Eop Onot (t1:::Enil), Eop Onot (t2:::Enil) => Eop Onand (t1:::t2:::Enil)
  | Eop Onot (t1:::Enil), t2 => Eop Oorn (t2:::t1:::Enil)
  | t1, Eop Onot (t2:::Enil) => Eop Oorn (t1:::t2:::Enil)
  | _, _ => insert e1 e2
  end.

Nondetfunction xorimm (n1: int) (e2: expr) :=
  if Int.eq n1 Int.zero then e2 else
  if Int.eq n1 Int.mone then notint e2 else
  match e2 with
  | Eop (Ointconst n2) Enil => Eop (Ointconst (Int.xor n1 n2)) Enil
  | Eop (Oxorimm n2) (t2:::Enil) => Eop (Oxorimm (Int.xor n1 n2)) (t2:::Enil)
  | Eop Onot (t2:::Enil) => Eop (Oxorimm (Int.not n1)) (t2:::Enil)
  | _ => Eop (Oxorimm n1) (e2:::Enil)
  end.

Nondetfunction xor (e1: expr) (e2: expr) :=
  match e1, e2 with
  | Eop (Ointconst n1) Enil, t2 => xorimm n1 t2
  | t1, Eop (Ointconst n2) Enil => xorimm n2 t1
  | Eop Onot (t1:::Enil), Eop Onot (t2:::Enil) => Eop Oxor (t1:::t2:::Enil)
  | _, _ => Eop Oxor (e1:::e2:::Enil)
  end.

(** ** Integer division and modulus *)

Definition divs_base (e1: expr) (e2: expr) := Eop Odiv (e1:::e2:::Enil).
Definition mods_base (e1: expr) (e2: expr) := Eop Omod (e1:::e2:::Enil).
Definition divu_base (e1: expr) (e2: expr) := Eop Odivu (e1:::e2:::Enil).
Definition modu_base (e1: expr) (e2: expr) := Eop Omodu (e1:::e2:::Enil).

Definition shrximm (e1: expr) (n2: int) :=
  if Int.eq n2 Int.zero then e1 else Eop (Oshrximm (mk_amount32 n2)) (e1:::Enil).

(** ** General shifts *)

Nondetfunction shl (e1: expr) (e2: expr) :=
  match e2 with
  | Eop (Ointconst n2) Enil => shlimm e1 n2
  | _ => Eop Osl (e1:::e2:::Enil)
  end.

Nondetfunction shr (e1: expr) (e2: expr) :=
  match e2 with
  | Eop (Ointconst n2) Enil => shrimm e1 n2
  | _ => Eop Oasr (e1:::e2:::Enil)
  end.

Nondetfunction shru (e1: expr) (e2: expr) :=
  match e2 with
  | Eop (Ointconst n2) Enil => shruimm e1 n2
  | _ => Eop Olsr (e1:::e2:::Enil)
  end.

(** ** Floating-point arithmetic *)

Definition negf (e: expr) :=  Eop Onegf (e ::: Enil).
Definition absf (e: expr) :=  Eop Oabsf (e ::: Enil).
Definition addf (e1 e2: expr) :=  Eop Oaddf (e1 ::: e2 ::: Enil).
Definition subf (e1 e2: expr) :=  Eop Osubf (e1 ::: e2 ::: Enil).
Definition mulf (e1 e2: expr) :=  Eop Omulf (e1 ::: e2 ::: Enil).

Definition negfs (e: expr) :=  Eop Onegfs (e ::: Enil).
Definition absfs (e: expr) :=  Eop Oabsfs (e ::: Enil).
Definition addfs (e1 e2: expr) :=  Eop Oaddfs (e1 ::: e2 ::: Enil).
Definition subfs (e1 e2: expr) :=  Eop Osubfs (e1 ::: e2 ::: Enil).
Definition mulfs (e1 e2: expr) :=  Eop Omulfs (e1 ::: e2 ::: Enil).

(** ** Comparisons *)

Nondetfunction compimm (default: comparison -> int -> condition)
                       (sem: comparison -> int -> int -> bool)
                       (c: comparison) (e1: expr) (n2: int) :=
  match c, e1 with
  | c, Eop (Ointconst n1) Enil =>
      Eop (Ointconst (if sem c n1 n2 then Int.one else Int.zero)) Enil
  | Ceq, Eop (Ocmp c) el =>
      if Int.eq_dec n2 Int.zero then
        Eop (Ocmp (negate_condition c)) el
      else if Int.eq_dec n2 Int.one then
        Eop (Ocmp c) el
      else
        Eop (Ointconst Int.zero) Enil
  | Cne, Eop (Ocmp c) el =>
      if Int.eq_dec n2 Int.zero then
        Eop (Ocmp c) el
      else if Int.eq_dec n2 Int.one then
        Eop (Ocmp (negate_condition c)) el
      else
        Eop (Ointconst Int.one) Enil
  | _, _ =>
       Eop (Ocmp (default c n2)) (e1 ::: Enil)
  end.

Nondetfunction comp (c: comparison) (e1: expr) (e2: expr) :=
  match e1, e2 with
  | Eop (Ointconst n1) Enil, t2 =>
      compimm Ccompimm Int.cmp (swap_comparison c) t2 n1
  | t1, Eop (Ointconst n2) Enil =>
      compimm Ccompimm Int.cmp c t1 n2
  | _, _ =>
      Eop (Ocmp (Ccomp c)) (e1 ::: e2 ::: Enil)
  end.
Nondetfunction compu (c: comparison) (e1: expr) (e2: expr) :=
  match e1, e2 with
  | Eop (Ointconst n1) Enil, t2 =>
      compimm Ccompuimm Int.cmpu (swap_comparison c) t2 n1
  | t1, Eop (Ointconst n2) Enil =>
      compimm Ccompuimm Int.cmpu c t1 n2
  | _, _ =>
      Eop (Ocmp (Ccompu c)) (e1 ::: e2 ::: Enil)
  end.

Definition compf (c: comparison) (e1: expr) (e2: expr) :=
  Eop (Ocmp (Ccompf c)) (e1 ::: e2 ::: Enil).

Definition compfs (c: comparison) (e1: expr) (e2: expr) :=
  Eop (Ocmp (Ccompfs c)) (e1 ::: e2 ::: Enil).

(** ** Integer conversions *)

Definition cast8unsigned (e: expr) := andimm (Int.repr 255) e.

Nondetfunction cast8signed (e: expr) :=
  match e with
  | Eop (Ointconst n) Enil => Eop (Ointconst (Int.sign_ext 8 n)) Enil
  | _ => Eop( Oextr (mk_amount32 Int.zero) (mk_amount32 (Int.repr 8))) (e ::: Enil)
  end.

Definition cast16unsigned (e: expr) := andimm (Int.repr 65535) e.

Nondetfunction cast16signed (e: expr) :=
  match e with
  | Eop (Ointconst n) Enil => Eop (Ointconst (Int.sign_ext 16 n)) Enil
  | _ => Eop( Oextr (mk_amount32 Int.zero) (mk_amount32 (Int.repr 16))) (e ::: Enil)
  end.

(** ** Floating-point conversions *)

Definition intoffloat  (e: expr) := Eop Ointoffloat (e ::: Enil).
Definition intuoffloat (e: expr) := Eop Ointuoffloat (e ::: Enil).

Nondetfunction floatofintu (e: expr) :=
  match e with
  | Eop (Ointconst n) Enil => Eop (Ofloatconst (Float.of_intu n)) Enil
  | _ => Eop Ofloatofintu (e ::: Enil)
  end.

Nondetfunction floatofint (e: expr) :=
  match e with
  | Eop (Ointconst n) Enil => Eop (Ofloatconst (Float.of_int n)) Enil
  | _ => Eop Ofloatofint (e ::: Enil)
  end.

Definition intofsingle (e: expr) := Eop Ointofsingle (e ::: Enil).
Definition intuofsingle (e: expr) := Eop Ointuofsingle (e ::: Enil).

Nondetfunction singleofint (e: expr) :=
  match e with
  | Eop (Ointconst n) Enil => Eop (Osingleconst (Float32.of_int n)) Enil
  | _ => Eop Osingleofint (e ::: Enil)
  end.

Nondetfunction singleofintu (e: expr) :=
  match e with
  | Eop (Ointconst n) Enil => Eop (Osingleconst (Float32.of_intu n)) Enil
  | _ => Eop Osingleofintu (e ::: Enil)
  end.

Definition singleoffloat (e: expr) := Eop Osingleoffloat (e ::: Enil).
Definition floatofsingle (e: expr) := Eop Ofloatofsingle (e ::: Enil).

(** ** Selection *)

Definition select (ty: typ) (cond: condition) (args: exprlist) (e1 e2: expr) :=
  if match ty with
     | Tint => true
     | Tsingle => true
     | _ => false
     end
  then Some (Eop (Osel cond ty) (e1 ::: e2 ::: args))
  else None.

(** ** Recognition of addressing modes for load and store operations *)

Nondetfunction addressing (chunk: memory_chunk) (e: expr) :=
  match e with
  | Eop (Oaddrsymbol s n) Enil => (Aglobal s n, Enil)
  | Eop (Oaddrstack n) Enil => (Ainstack n, Enil)
  | Eop (Oaddimm n) (e1:::Enil) => (Aindexed n, e1:::Enil)
  | _ => (Aindexed Int.zero, e:::Enil)
  end.

(** ** Arguments of builtins *)

Nondetfunction builtin_arg (e: expr) :=
  match e with
  | Eop (Ointconst n) Enil => BA_int n
  | Eop (Oaddrsymbol id ofs) Enil => BA_addrglobal id ofs
  | Eop (Oaddrstack ofs) Enil => BA_addrstack ofs
  | Eop Omakelong (Eop (Ointconst h) Enil ::: Eop (Ointconst l) Enil ::: Enil) =>
        BA_long (Int64.ofwords h l)
  | Eop Omakelong (h ::: l ::: Enil) => BA_splitlong (BA h) (BA l)
  | Eload chunk (Ainstack ofs) Enil => BA_loadstack chunk ofs
  | Eop (Oaddimm n) (e1:::Enil) =>
        BA_addptr (BA e1) (BA_int n)
  | _ => BA e
  end.

(** Platform-specific known builtins *)

Definition platform_builtin (b: platform_builtin) (args: exprlist) : option expr :=
  None.

(** Platform-specific expansion of standard builtins *)

Definition platform_standard_builtin (b: standard_builtin) (args: exprlist) : option expr :=
  None.
