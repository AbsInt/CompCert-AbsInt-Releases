(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Bernhard Schommer, AbsInt Angewandte Informatik GmbH       *)
(*                                                                     *)
(*  AbsInt Angewandte Informatik GmbH. All rights reserved. This file  *)
(*  is distributed under the terms of the INRIA Non-Commercial         *)
(*  License Agreement.                                                 *)
(*                                                                     *)
(* *********************************************************************)

(** Correctness of instruction selection for operators *)

Require Import Coqlib Zbits.
Require Import AST Integers Floats Values Memory Builtins Globalenvs.
Require Import Cminor Op CminorSel.
Require Import SelectOp.

Local Open Scope cminorsel_scope.
Local Transparent Archi.ptr64.

(** * Useful lemmas and tactics *)

(** The following are trivial lemmas and custom tactics that help
  perform backward (inversion) and forward reasoning over the evaluation
  of operator applications. *)

Ltac EvalOp :=
  eauto with evalexpr;
  match goal with
  | [ |- eval_expr _ _ _ _ _ _ _ ] => eapply eval_Eop; [EvalOp|try reflexivity; auto]
  | [ |- eval_exprlist _ _ _ _ _ _ _ ] => econstructor; EvalOp
  | _ => idtac
  end.

Ltac InvEval1 :=
  match goal with
  | [ H: (eval_expr _ _ _ _ _ (Eop _ Enil) _) |- _ ] =>
      inv H; InvEval1
  | [ H: (eval_expr _ _ _ _ _ (Eop _ (_ ::: Enil)) _) |- _ ] =>
      inv H; InvEval1
  | [ H: (eval_expr _ _ _ _ _ (Eop _ (_ ::: _ ::: Enil)) _) |- _ ] =>
      inv H; InvEval1
  | [ H: (eval_exprlist _ _ _ _ _ Enil _) |- _ ] =>
      inv H; InvEval1
  | [ H: (eval_exprlist _ _ _ _ _ (_ ::: _) _) |- _ ] =>
      inv H; InvEval1
  | _ =>
      idtac
  end.

Ltac InvEval2 :=
  match goal with
  | [ H: (eval_operation _ _ _ nil _ = Some _) |- _ ] =>
      simpl in H; inv H
  | [ H: (eval_operation _ _ _ (_ :: nil) _ = Some _) |- _ ] =>
      simpl in H; FuncInv
  | [ H: (eval_operation _ _ _ (_ :: _ :: nil) _ = Some _) |- _ ] =>
      simpl in H; FuncInv
  | [ H: (eval_operation _ _ _ (_ :: _ :: _ :: nil) _ = Some _) |- _ ] =>
      simpl in H; FuncInv
  | _ =>
      idtac
  end.

Ltac InvEval := InvEval1; InvEval2; InvEval2.

Ltac TrivialExists :=
  match goal with
  | [ |- exists v, _ /\ Val.lessdef ?a v ] => exists a; split; [EvalOp | auto]
  end.

(** * Correctness of the smart constructors *)

Section CMCONSTR.

Variable ge: genv.
Variable sp: val.
Variable e: env.
Variable m: mem.

(** We now show that the code generated by "smart constructor" functions
  such as [Selection.notint] behaves as expected.  Continuing the
  [notint] example, we show that if the expression [e]
  evaluates to some integer value [Vint n], then [Selection.notint e]
  evaluates to a value [Vint (Int.not n)] which is indeed the integer
  negation of the value of [e].

  All proofs follow a common pattern:
- Reasoning by case over the result of the classification functions
  (such as [add_match] for integer addition), gathering additional
  information on the shape of the argument expressions in the non-default
  cases.
- Inversion of the evaluations of the arguments, exploiting the additional
  information thus gathered.
- Equational reasoning over the arithmetic operations performed,
  using the lemmas from the [Int] and [Float] modules.
- Construction of an evaluation derivation for the expression returned
  by the smart constructor.
*)

Definition unary_constructor_sound (cstr: expr -> expr) (sem: val -> val) : Prop :=
  forall le a x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (cstr a) v /\ Val.lessdef (sem x) v.

Definition binary_constructor_sound (cstr: expr -> expr -> expr) (sem: val -> val -> val) : Prop :=
  forall le a x b y,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  exists v, eval_expr ge sp e m le (cstr a b) v /\ Val.lessdef (sem x y) v.

(** ** Constants *)

Theorem eval_addrsymbol:
  forall le id ofs,
  exists v, eval_expr ge sp e m le (addrsymbol id ofs) v /\ Val.lessdef (Genv.symbol_address ge id ofs) v.
Proof.
  intros. unfold addrsymbol. TrivialExists.
Qed.

Theorem eval_addrstack:
  forall le ofs,
  exists v, eval_expr ge sp e m le (addrstack ofs) v /\ Val.lessdef (Val.offset_ptr sp ofs) v.
Proof.
  intros. unfold addrstack. TrivialExists.
Qed.

(** ** Addition, opposite, subtraction *)

Theorem eval_addimm:
  forall n, unary_constructor_sound (addimm n) (fun x => Val.add x (Vint n)).
Proof.
  red; unfold addimm; intros until x.
  predSpec Int.eq Int.eq_spec n Int.zero.
  - subst n. intros. exists x; split; auto. destruct x; simpl; auto.
    rewrite Int.add_zero. auto. rewrite Ptrofs.add_zero. auto.
  - case (addimm_match a); intros; InvEval; simpl; TrivialExists; simpl.
    + rewrite Int.add_commut. auto.
    + unfold Genv.symbol_address. destruct (Genv.find_symbol ge s); simpl; auto. rewrite Ptrofs.add_commut; auto.
    + destruct sp; simpl; auto. rewrite Ptrofs.add_assoc. do 3 f_equal. apply Ptrofs.add_commut.
    + subst. rewrite Val.add_assoc. rewrite Int.add_commut. auto.
Qed.

Theorem eval_add: binary_constructor_sound add Val.add.
Proof.
  red; intros until y.
  unfold add; case (add_match a b); intros; InvEval; subst.
  - rewrite Val.add_commut. apply eval_addimm; auto.
  - apply eval_addimm; auto.
  - replace (Val.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2)))
     with (Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2))).
  apply eval_addimm. EvalOp.
    repeat rewrite Val.add_assoc. decEq. apply Val.add_permut.
  - subst. econstructor; split. EvalOp.
    rewrite Val.add_commut. destruct sp; simpl; auto.
    destruct v1; simpl; auto.
    apply Val.lessdef_same. f_equal.
    rewrite ! Ptrofs.add_assoc. f_equal.
    rewrite (Ptrofs.add_commut (Ptrofs.of_int n1)), Ptrofs.add_assoc.
    f_equal. auto with ptrofs.
  - subst. econstructor; split. EvalOp.
    destruct sp, v1; simpl; auto.
    apply Val.lessdef_same. f_equal. rewrite ! Ptrofs.add_assoc. f_equal.
    f_equal.
    rewrite Ptrofs.add_commut. auto with ptrofs.
  - rewrite Val.add_assoc, Val.add_permut, Val.add_commut.
    apply eval_addimm. EvalOp.
  - replace (Val.add x (Val.add v1 (Vint n2)))
        with (Val.add (Val.add x v1) (Vint n2)).
    apply eval_addimm. EvalOp.
    repeat rewrite Val.add_assoc. reflexivity.
  - TrivialExists.
  - rewrite Val.add_commut. TrivialExists.
  - TrivialExists.
  - rewrite Val.add_commut. TrivialExists.
  - TrivialExists.
Qed.

Theorem eval_subimm:
  forall n, unary_constructor_sound (subimm n) (fun v => Val.sub (Vint n) v).
Proof.
  intros; red; intros until x. unfold subimm.
  destruct (subimm_match a); intros; InvEval; subst; TrivialExists.
  destruct v1; simpl; auto.
  rewrite ! Int.sub_add_opp, Int.add_assoc. do 3 f_equal.
  rewrite Int.neg_add_distr. apply Int.add_commut.
Qed.


Theorem eval_sub: binary_constructor_sound sub Val.sub.
Proof.
  red; intros until y.
  unfold sub; case (sub_match a b); intros; InvEval.
  rewrite Val.sub_add_opp. apply eval_addimm; auto.
  - apply eval_subimm; auto.
  - subst. rewrite Val.sub_add_l, Val.sub_add_r, Val.add_assoc.
    simpl. rewrite Int.add_commut, <- Int.sub_add_opp.
    apply eval_addimm; EvalOp.
  - subst. rewrite Val.sub_add_l. apply eval_addimm; EvalOp.
  - subst. rewrite Val.sub_add_r. apply eval_addimm; EvalOp.
  - subst. TrivialExists.
  - subst. TrivialExists.
  - TrivialExists.
Qed.

Theorem eval_negint: unary_constructor_sound negint (fun v => Val.sub Vzero v).
Proof.
  red; intros. TrivialExists.
Qed.

(** ** Immediate shift *)

Theorem eval_shlimm:
  forall n, unary_constructor_sound (fun a => shlimm a n)
                                    (fun x => Val.shl x (Vint n)).
Proof.
Local Opaque mk_amount32.
  red; intros until x; unfold shlimm.
  predSpec Int.eq Int.eq_spec n Int.zero; [| destruct (Int.ltu n Int.iwordsize) eqn:L]; simpl.
- intros; subst. exists x; split; auto. destruct x; simpl; auto. rewrite Int.shl_zero; auto.
- destruct (shlimm_match a); intros; InvEval; subst.
  + TrivialExists. simpl; rewrite L; auto.
  + TrivialExists. simpl; rewrite mk_amount32_eq; auto.
- intros. TrivialExists.
Qed.


Remark  w_shift_amount:
  forall n, Int.sub Int.iwordsize (Int.sub Int.iwordsize n) = n.
Proof.
  intros.
  rewrite (Int.sub_add_opp _ n), Int.add_commut, Int.sub_add_r, Int.sub_idem.
  rewrite Int.neg_involutive, Int.add_zero_l. reflexivity.
Qed.

Remark p_shift_amount:
  forall n1 n2, Int.sub n1 (Int.sub n1 n2) = n2.
Proof.
  intros.
  rewrite ! Int.sub_add_opp, Int.neg_add_distr, Int.neg_involutive, <- Int.add_assoc, Int.add_neg_zero, Int.add_zero_l.
  reflexivity.
Qed.

Theorem eval_shrimm:
  forall n, unary_constructor_sound (fun a => shrimm a n)
                                    (fun x => Val.shr x (Vint n)).
Proof.
  red; intros until x; unfold shrimm.
  predSpec Int.eq Int.eq_spec n Int.zero; [| destruct (Int.ltu n Int.iwordsize) eqn:L]; simpl.
  - intros; subst. exists x; split; auto. destruct x; simpl; auto. rewrite Int.shr_zero; auto.
  - destruct (shrimm_match a); intros; InvEval; subst.
    + TrivialExists. simpl; rewrite L; auto.
    + assert (DEF: exists v, eval_expr ge sp e m le
                                  (Eop (Oasrimm (mk_amount32 n)) (Eop (Oslimm n1) (e2 ::: Enil) ::: Enil)) v
                        /\  Val.lessdef (Val.shr (Val.shl v1 (Vint n1)) (Vint n)) v).
      { TrivialExists. simpl; rewrite mk_amount32_eq; auto. }
      destruct (Int.ltu (Int.sub n n1) Int.iwordsize) eqn:?;  eauto.
      destruct (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) eqn:?; eauto.
      TrivialExists. simpl; repeat rewrite mk_amount32_eq; auto.
      unfold extr.
      rewrite w_shift_amount, p_shift_amount. reflexivity.
    + TrivialExists. simpl; rewrite mk_amount32_eq; auto.
  - intros; TrivialExists.
Qed.

Theorem eval_shruimm:
  forall n, unary_constructor_sound (fun a => shruimm a n)
                                    (fun x => Val.shru x (Vint n)).
Proof.
Local Opaque Int.zwordsize.
  red; intros until x; unfold shruimm.
  predSpec Int.eq Int.eq_spec n Int.zero; [| destruct (Int.ltu n Int.iwordsize) eqn:L]; simpl.
- intros; subst. exists x; split; auto. destruct x; simpl; auto. rewrite Int.shru_zero; auto.
- destruct (shruimm_match a); intros; InvEval; subst.
  + TrivialExists. simpl; rewrite L; auto.
  + assert (DEF: exists v, eval_expr ge sp e m le
                                  (Eop (Olsrimm (mk_amount32 n)) (Eop (Oslimm n1) (e2 ::: Enil) ::: Enil)) v
                        /\  Val.lessdef (Val.shru (Val.shl v1 (Vint n1)) (Vint n)) v).
      { TrivialExists. simpl; rewrite mk_amount32_eq; auto. }
      destruct (Int.ltu (Int.sub n n1) Int.iwordsize) eqn:?;  eauto.
      destruct (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) eqn:?; eauto.
      TrivialExists. simpl; repeat rewrite mk_amount32_eq; auto.
      unfold extru.
      rewrite w_shift_amount, p_shift_amount. reflexivity.
  + TrivialExists. simpl; rewrite mk_amount32_eq; auto.
- intros; TrivialExists.
Qed.

(** ** Multiplication *)

Lemma eval_mulimm_base:
  forall n, unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)).
Proof.
  intros; red; intros; unfold mulimm_base.
  generalize (Int.one_bits_decomp n); generalize (Int.one_bits_range n);
    destruct (Int.one_bits n) as [ | i [ | j []]]; intros P Q; [TrivialExists | | | TrivialExists].
  - replace (Val.mul x (Vint n)) with (Val.shl x (Vint i)).
    apply eval_shlimm; auto.
    simpl in Q. rewrite <- Val.shl_mul, Q, Int.add_zero. simpl. rewrite P by auto with coqlib. auto.
  - exploit (eval_shlimm i (x :: le) (Eletvar 0) x). constructor; auto. intros [v1 [A1 B1]].
    exploit (eval_shlimm j (x :: le) (Eletvar 0) x). constructor; auto. intros [v2 [A2 B2]].
    exploit (eval_add (x :: le)). eexact A1. eexact A2. intros [v [A B]].
    exists v; split. econstructor; eauto.
    simpl in Q. rewrite Q, Int.add_zero.
    replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))
      with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).
    rewrite Val.mul_add_distr_r.
    repeat rewrite Val.shl_mul. eapply Val.lessdef_trans; [|eauto]. apply Val.add_lessdef; auto.
    simpl. repeat rewrite P by auto with coqlib. auto.
Qed.

Theorem eval_mulimm:
  forall n, unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)).
Proof.
  intros; red; intros until x; unfold mulimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  intros. exists (Vint Int.zero); split. EvalOp.
  destruct x; simpl; auto. subst n. rewrite Int.mul_zero. auto.
  predSpec Int.eq Int.eq_spec n Int.one.
  intros. exists x; split; auto.
  destruct x; simpl; auto. subst n. rewrite Int.mul_one. auto.
  case (mulimm_match a); intros; InvEval; subst.
  - TrivialExists. simpl. rewrite Int.mul_commut; auto.
  - rewrite Val.mul_add_distr_l.
    exploit eval_mulimm_base; eauto. instantiate (1 := n). intros [v' [A1 B1]].
    exploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v'). auto. intros [v'' [A2 B2]].
    exists v''; split; auto. eapply Val.lessdef_trans. eapply Val.add_lessdef; eauto.
    rewrite Val.mul_commut; auto.
  - apply eval_mulimm_base; auto.
Qed.

Theorem eval_mul: binary_constructor_sound mul Val.mul.
Proof.
  red; intros until y; unfold mul; case (mul_match a b); intros; InvEval; subst.
  - rewrite Val.mul_commut. apply eval_mulimm; auto.
  - apply eval_mulimm; auto.
  - TrivialExists.
Qed.

Theorem eval_mulhs: binary_constructor_sound mulhs Val.mulhs.
Proof.
  unfold mulhs; red; intros; TrivialExists.
Qed.

Theorem eval_mulhu: binary_constructor_sound mulhu Val.mulhu.
Proof.
  unfold mulhu; red; intros; TrivialExists.
Qed.

(** ** Bitwise not *)

Theorem eval_notint: unary_constructor_sound notint Val.notint.
Proof.
  unfold notint; red; intros until x; case (notint_match a); intros; InvEval; subst.
  - TrivialExists.
  - econstructor; split. EvalOp.
    destruct v1; simpl; auto.
    rewrite Int.not_involutive. auto.
  - TrivialExists. destruct v0; simpl; auto. rewrite Int.and_commut. auto.
  - TrivialExists.
  - TrivialExists.
  - TrivialExists.
  - TrivialExists.
  - TrivialExists. destruct v0, v1; simpl; auto. rewrite Int.not_involutive. auto.
  - TrivialExists. destruct v0, v1; simpl; auto.
    rewrite Int.not_and_or_not, Int.not_involutive, Int.or_commut. auto.
  - TrivialExists. destruct v0, v1; simpl; auto.
    rewrite Int.not_or_and_not, Int.not_involutive, Int.and_commut. auto.
  - TrivialExists. destruct v0, v1; simpl; auto. rewrite Int.not_involutive. auto.
  - TrivialExists. destruct v0, v1; simpl; auto. rewrite Int.not_involutive. auto.
  - rewrite Val.not_xor, Val.xor_assoc. TrivialExists.
  - TrivialExists.
Qed.

(** ** Bitwise and, or, xor *)

Theorem eval_andimm:
  forall n, unary_constructor_sound (andimm n) (fun x => Val.and x (Vint n)).
Proof.
  intros; red; intros until x. unfold andimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  exists (Vint Int.zero); split. EvalOp.
  destruct x; simpl; auto. subst n. rewrite Int.and_zero. auto.
  predSpec Int.eq Int.eq_spec n Int.mone.
  exists x; split; auto.
  subst. destruct x; simpl; auto. rewrite Int.and_mone; auto.
  case (andimm_match a); intros; InvEval; subst.
- rewrite Int.and_commut; TrivialExists.
- rewrite Val.and_assoc, Int.and_commut. simpl. TrivialExists.
- TrivialExists.
Qed.

Theorem eval_and: binary_constructor_sound and Val.and.
Proof.
  red; intros until y; unfold and; case (and_match a b); intros; InvEval; subst.
- rewrite Val.and_commut; apply eval_andimm; auto.
- apply eval_andimm; auto.
- TrivialExists. destruct v0, v1; simpl; auto.
  rewrite Int.not_or_and_not. auto.
- rewrite Val.and_commut; TrivialExists.
- TrivialExists.
- TrivialExists.
Qed.

Theorem eval_orimm:
  forall n, unary_constructor_sound (orimm n) (fun x => Val.or x (Vint n)).
Proof.
  intros; red; intros until x. unfold orimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  intros. subst. exists x; split; auto.
  destruct x; simpl; auto. rewrite Int.or_zero; auto.
  predSpec Int.eq Int.eq_spec n Int.mone.
  intros. exists (Vint Int.mone); split. EvalOp.
  destruct x; simpl; auto. subst n. rewrite Int.or_mone. auto.
  destruct (orimm_match a); intros; InvEval; subst.
- rewrite Int.or_commut; TrivialExists.
- rewrite Val.or_assoc, Int.or_commut; TrivialExists.
- TrivialExists.
Qed.

Lemma insert_sem:
  forall i v1 v2 amount mask nmask,
    Int.is_power2 (Int.add (Int.shr mask amount) Int.one) = Some i ->
    Int.eq (Int.shl (Int.sub (Int.repr (two_p (Int.unsigned i))) Int.one) amount) mask = true ->
    Int.eq nmask (Int.not mask) = true ->
    insert_bits amount (mk_amount32 i) v2 v1
    =
    Val.or (Val.and (Val.shl v1 (Vint amount)) (Vint mask)) (Val.and v2 (Vint nmask)).
Proof.
  intros i v1 v2 amount mask nmask H1 H2%Int.same_if_eq H3%Int.same_if_eq.
  unfold insert_bits. rewrite Val.or_commut.
  rewrite mk_amount32_eq by (eapply Int.is_power2_range; eauto).
  rewrite H2, H3. reflexivity.
Qed.

Theorem eval_insert: binary_constructor_sound insert Val.or.
Proof.
  red; intros until y; unfold insert; case (insert_match a b); intros; InvEval.
  - unfold insert_mask_nmask, insert_mask, is_mask.
    inv H6. inv H7. inv H9.
    destruct (Int.eq nmask (Int.not mask)) eqn:Heq; [|TrivialExists].
    destruct (Int.is_power2 (Int.add (Int.shr mask amount) Int.one)) eqn:Hpow; [|TrivialExists].
    destruct (Int.eq (Int.shl (Int.sub (Int.repr (two_p (Int.unsigned i))) Int.one) amount)) eqn:?; TrivialExists.
    destruct t2.
    all: EvalOp; try (simpl; erewrite insert_sem; eauto). 
    destruct o eqn:?.
    all: try (EvalOp; simpl; erewrite insert_sem; eauto).
    inv H2. inv H6. destruct vl; try easy.
    now injection H0 as [=->].
  - unfold insert_mask_nmask, insert_mask, is_mask.
    inv H6. inv H7. inv H9.
    destruct (Int.eq nmask (Int.not mask)) eqn:Heq; [|TrivialExists].
    destruct (Int.is_power2 (Int.add (Int.shr mask amount) Int.one)) eqn:Hpow; [|TrivialExists].
    destruct (Int.eq (Int.shl (Int.sub (Int.repr (two_p (Int.unsigned i))) Int.one) amount)) eqn:?; TrivialExists.
    destruct t2.
    all: EvalOp; simpl; try erewrite insert_sem, Val.or_commut; eauto.
    destruct o eqn:?.
    all: EvalOp; simpl; try erewrite insert_sem, Val.or_commut; eauto.
    inv H3. inv H6. destruct vl; try easy.
    injection H0 as [=->]. reflexivity.
  - unfold insert_mask_mask, insert_mask, is_mask.
    inv H6. inv H7. inv H9.
    destruct (Int.eq mask1 mask2) eqn:?; TrivialExists.
    rewrite <- (Int.same_if_eq _ _ Heqb0) in *.
    destruct (Int.is_power2 (Int.add (Int.shr mask1 amount) Int.one)) eqn:Hpow.
    + destruct (Int.eq (Int.shl (Int.sub (Int.repr (two_p (Int.unsigned i))) Int.one) amount)) eqn:?.
      * destruct t2.
        all: EvalOp; simpl; try erewrite insert_sem, Val.or_commut; eauto using Int.eq_true.
        destruct o eqn:?.
        all: EvalOp; simpl; try erewrite insert_sem, Val.or_commut; eauto using Int.eq_true.
        inv H3. inv H6. destruct vl; try easy.
        injection H0 as [=->]. reflexivity.
      * now repeat econstructor.
    + now repeat econstructor.
  - unfold insert_mask_mask, insert_mask, is_mask.
    inv H6. inv H7. inv H9.
    destruct (Int.eq mask1 mask2) eqn:?; TrivialExists.
    rewrite <- (Int.same_if_eq _ _ Heqb0) in *.
    destruct (Int.is_power2 (Int.add (Int.shr mask1 amount) Int.one)) eqn:Hpow.
    + destruct (Int.eq (Int.shl (Int.sub (Int.repr (two_p (Int.unsigned i))) Int.one) amount)) eqn:?.
      * destruct t2.
        all: EvalOp; simpl; try erewrite insert_sem; eauto using Int.eq_true.
        destruct o eqn:?.
        all: EvalOp; simpl; try erewrite insert_sem; eauto using Int.eq_true.
        inv H2. inv H6. destruct vl; try easy.
        injection H0 as [=->]. reflexivity.
      * now repeat econstructor.
    + now repeat econstructor.
  - TrivialExists.
Qed.

Theorem eval_or: binary_constructor_sound or Val.or.
Proof.
  red; intros until y; unfold or; case (or_match a b); intros; InvEval; subst.
  - rewrite Val.or_commut. apply eval_orimm; auto.
  - apply eval_orimm; auto.
  - TrivialExists. destruct v0, v1; simpl; auto.
    rewrite Int.not_and_or_not. auto.
  - rewrite Val.or_commut; TrivialExists.
  - TrivialExists.
  - apply eval_insert; auto.
Qed.

Theorem eval_xorimm:
  forall n, unary_constructor_sound (xorimm n) (fun x => Val.xor x (Vint n)).
Proof.
  intros; red; intros until x. unfold xorimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  intros. exists x; split. auto.
  destruct x; simpl; auto. subst n. rewrite Int.xor_zero. auto.
  predSpec Int.eq Int.eq_spec n Int.mone.
  subst n. rewrite <- Val.not_xor. apply eval_notint; auto.
  destruct (xorimm_match a); intros; InvEval; subst.
  - rewrite Int.xor_commut; TrivialExists.
  - rewrite Val.xor_assoc; simpl. rewrite (Int.xor_commut n2). TrivialExists.
  - TrivialExists. simpl. rewrite Val.not_xor. rewrite Val.xor_assoc. simpl.
    rewrite Int.xor_commut. auto.
  - TrivialExists.
Qed.

Theorem eval_xor: binary_constructor_sound xor Val.xor.
Proof.
  red; intros until y; unfold xor; case (xor_match a b); intros; InvEval.
  - rewrite Val.xor_commut. apply eval_xorimm; auto.
  - apply eval_xorimm; auto.
  - TrivialExists; subst; simpl.
    destruct v0, v1; simpl; auto.
    rewrite Int.xor_not_xor. auto.
  - TrivialExists.
Qed.

(** ** Integer division and modulus *)

Theorem eval_divs_base:
  forall le a b x y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.divs x y = Some z ->
  exists v, eval_expr ge sp e m le (divs_base a b) v /\ Val.lessdef z v.
Proof.
  intros. unfold divs_base. exists z; split. EvalOp. auto.
Qed.


Theorem eval_mods_base:
  forall le a b x y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.mods x y = Some z ->
  exists v, eval_expr ge sp e m le (mods_base a b) v /\ Val.lessdef z v.
Proof.
  intros. unfold mods_base. exists z; split. EvalOp. auto.
Qed.

Theorem eval_divu_base:
  forall le a b x y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.divu x y = Some z ->
  exists v, eval_expr ge sp e m le (divu_base a b) v /\ Val.lessdef z v.
Proof.
  intros. unfold divu_base. exists z; split. EvalOp. auto.
Qed.

Theorem eval_modu_base:
  forall le a b x y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.modu x y = Some z ->
  exists v, eval_expr ge sp e m le (modu_base a b) v /\ Val.lessdef z v.
Proof.
  intros. unfold modu_base. exists z; split. EvalOp. auto.
Qed.

Theorem eval_shrximm:
  forall le a n x z,
  eval_expr ge sp e m le a x ->
  Val.shrx x (Vint n) = Some z ->
  exists v, eval_expr ge sp e m le (shrximm a n) v /\ Val.lessdef z v.
Proof.
  intros. unfold shrximm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  subst n. exists x; split; auto.
  destruct x; simpl in H0; try discriminate.
  destruct (Int.ltu Int.zero (Int.repr 31)); inv H0.
  replace (Int.shrx i Int.zero) with i. auto.
  unfold Int.shrx, Int.divs. rewrite Int.shl_zero.
  change (Int.signed Int.one) with 1. rewrite Z.quot_1_r. rewrite Int.repr_signed; auto.
  assert (Int.ltu n (Int.repr 32) = true).
  {
    destruct (Int.ltu n (Int.repr 31)) eqn:?.
    apply zlt_true. apply Int.ltu_inv in Heqb.
    change (Int.unsigned (Int.repr 31)) with 31 in Heqb.
    change (Int.unsigned (Int.repr 32)) with 32. lia.
    unfold Val.shrx in H0. rewrite Heqb in H0.
    destruct x; inv H0.
  }
  econstructor; split. EvalOp. simpl. rewrite mk_amount32_eq; auto.
  eauto.
  auto.
Qed.

(** ** General shifts *)

Theorem eval_shl: binary_constructor_sound shl Val.shl.
Proof.
  red; intros until y; unfold shl; case (shl_match b); intros.
  InvEval. apply eval_shlimm; auto.
  TrivialExists.
Qed.

Theorem eval_shr: binary_constructor_sound shr Val.shr.
Proof.
  red; intros until y; unfold shr; case (shr_match b); intros.
  InvEval. apply eval_shrimm; auto.
  TrivialExists.
Qed.

Theorem eval_shru: binary_constructor_sound shru Val.shru.
Proof.
  red; intros until y; unfold shru; case (shru_match b); intros.
  InvEval. apply eval_shruimm; auto.
  TrivialExists.
Qed.

(** ** Floating-point arithmetic *)


Theorem eval_negf: unary_constructor_sound negf Val.negf.
Proof.
  red; intros. TrivialExists.
Qed.

Theorem eval_absf: unary_constructor_sound absf Val.absf.
Proof.
  red; intros. TrivialExists.
Qed.

Theorem eval_addf: binary_constructor_sound addf Val.addf.
Proof.
  red; intros; TrivialExists.
Qed.

Theorem eval_subf: binary_constructor_sound subf Val.subf.
Proof.
  red; intros; TrivialExists.
Qed.

Theorem eval_mulf: binary_constructor_sound mulf Val.mulf.
Proof.
  red; intros; TrivialExists.
Qed.

Theorem eval_negfs: unary_constructor_sound negfs Val.negfs.
Proof.
  red; intros. TrivialExists.
Qed.

Theorem eval_absfs: unary_constructor_sound absfs Val.absfs.
Proof.
  red; intros. TrivialExists.
Qed.

Theorem eval_addfs: binary_constructor_sound addfs Val.addfs.
Proof.
  red; intros; TrivialExists.
Qed.

Theorem eval_subfs: binary_constructor_sound subfs Val.subfs.
Proof.
  red; intros; TrivialExists.
Qed.

Theorem eval_mulfs: binary_constructor_sound mulfs Val.mulfs.
Proof.
  red; intros; TrivialExists.
Qed.

Section COMP_IMM.

Variable default: comparison -> int -> condition.
Variable intsem: comparison -> int -> int -> bool.
Variable sem: comparison -> val -> val -> val.

Hypothesis sem_int: forall c x y, sem c (Vint x) (Vint y) = Val.of_bool (intsem c x y).
Hypothesis sem_undef: forall c v, sem c Vundef v = Vundef.
Hypothesis sem_eq: forall x y, sem Ceq (Vint x) (Vint y) = Val.of_bool (Int.eq x y).
Hypothesis sem_ne: forall x y, sem Cne (Vint x) (Vint y) = Val.of_bool (negb (Int.eq x y)).
Hypothesis sem_default: forall c v n, sem c v (Vint n) = Val.of_optbool (eval_condition (default c n) (v :: nil) m).

Lemma eval_compimm:
  forall le c a n2 x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (compimm default intsem c a n2) v
         /\ Val.lessdef (sem c x (Vint n2)) v.
Proof.
  intros until x.
  unfold compimm; case (compimm_match c a); intros; InvEval; subst.
  - (* constant *)
    rewrite sem_int. TrivialExists. simpl. destruct (intsem c0 n1 n2); auto.
  - (* eq cmp *)
    inv H. simpl in H5. inv H5.
    destruct (Int.eq_dec n2 Int.zero). subst n2. TrivialExists.
    simpl. rewrite eval_negate_condition.
    destruct (eval_condition c0 vl m); simpl.
    unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_eq; auto.
    rewrite sem_undef; auto.
    destruct (Int.eq_dec n2 Int.one). subst n2. TrivialExists.
    simpl. destruct (eval_condition c0 vl m); simpl.
    unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_eq; auto.
    rewrite sem_undef; auto.
    exists (Vint Int.zero); split. EvalOp.
    destruct (eval_condition c0 vl m); simpl.
    unfold Vtrue, Vfalse. destruct b; rewrite sem_eq; rewrite Int.eq_false; auto.
    rewrite sem_undef; auto.
  - (* ne cmp *)
    inv H. simpl in H5. inv H5.
    destruct (Int.eq_dec n2 Int.zero). subst n2. TrivialExists.
    simpl. destruct (eval_condition c0 vl m); simpl.
    unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_ne; auto.
    rewrite sem_undef; auto.
    destruct (Int.eq_dec n2 Int.one). subst n2. TrivialExists.
    simpl. rewrite eval_negate_condition. destruct (eval_condition c0 vl m); simpl.
    unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_ne; auto.
    rewrite sem_undef; auto.
    exists (Vint Int.one); split. EvalOp.
    destruct (eval_condition c0 vl m); simpl.
    unfold Vtrue, Vfalse. destruct b; rewrite sem_ne; rewrite Int.eq_false; auto.
    rewrite sem_undef; auto.
  - TrivialExists. simpl. rewrite sem_default. auto.
Qed.

Hypothesis sem_swap:
  forall c x y, sem (swap_comparison c) x y = sem c y x.

Lemma eval_compimm_swap:
  forall le c a n2 x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v
         /\ Val.lessdef (sem c (Vint n2) x) v.
Proof.
  intros. rewrite <- sem_swap. eapply eval_compimm; eauto.
Qed.

End COMP_IMM.

Theorem eval_comp:
  forall c, binary_constructor_sound (comp c) (Val.cmp c).
Proof.
  intros; red; intros until y. unfold comp; case (comp_match a b); intros; InvEval; subst.
- eapply eval_compimm_swap; eauto.
  intros. unfold Val.cmp. rewrite Val.swap_cmp_bool; auto.
- eapply eval_compimm; eauto.
- TrivialExists.
Qed.

Theorem eval_compu:
  forall c, binary_constructor_sound (compu c) (Val.cmpu (Mem.valid_pointer m) c).
Proof.
  intros; red; intros until y. unfold compu; case (compu_match a b); intros; InvEval; subst.
- eapply eval_compimm_swap; eauto.
  intros. unfold Val.cmpu. rewrite Val.swap_cmpu_bool; auto.
- eapply eval_compimm; eauto.
- TrivialExists.
Qed.

Theorem eval_compf:
  forall c, binary_constructor_sound (compf c) (Val.cmpf c).
Proof.
  intros; red; intros. unfold compf. TrivialExists.
Qed.

Theorem eval_compfs:
  forall c, binary_constructor_sound (compfs c) (Val.cmpfs c).
Proof.
  intros; red; intros. unfold compfs. TrivialExists.
Qed.

(** Integer conversions *)

Theorem eval_cast8unsigned: unary_constructor_sound cast8unsigned (Val.zero_ext 8).
Proof.
  red; intros. unfold cast8unsigned.
  rewrite Val.zero_ext_and. apply eval_andimm; auto. lia.
Qed.

Lemma extr_sign_ext:
  forall x y,
  0 < y < 32 ->
  let sa := Int.sub Int.iwordsize (Int.repr y) in
  Val.shr (Val.shl x (Vint sa)) (Vint sa) =
    Val.sign_ext y x.
Proof.
  intros.
  destruct H. destruct x; simpl; auto.
  assert (Int.unsigned (Int.repr y) = y).
  apply  Int.unsigned_repr. unfold Int.max_unsigned. simpl. split; lia.
  assert (Int.ltu sa Int.iwordsize = true).
  { subst sa. unfold Int.ltu.
    replace (Int.unsigned Int.iwordsize) with 32 in * by auto.
    rewrite Int.unsigned_sub_borrow.
    unfold Int.sub_borrow.
    replace (Int.unsigned Int.iwordsize) with 32 by auto.
    rewrite H1.
    rewrite Z.sub_0_r.
    replace (Int.unsigned (if zlt (32 - y) 0 then Int.one else Int.zero)) with 0.
    rewrite Z.mul_0_l. rewrite Z.add_0_r.
    destruct (zlt (32 - y)); auto. lia.
    destruct (zlt (32 - y) 0); auto. lia.
  }
  rewrite H2. simpl. rewrite H2. f_equal.
  rewrite (Int.shr_shl i sa sa); auto.
  replace (Int.ltu sa sa) with false.
  rewrite Int.sub_idem, Int.shr_zero.
  replace (Int.zwordsize -  Int.unsigned sa) with y.
  reflexivity.
  subst sa. rewrite Int.unsigned_sub_borrow.
  unfold Int.sub_borrow.
  replace (Int.unsigned Int.iwordsize) with Int.zwordsize by auto.
  rewrite H1, Z.sub_0_r.
  destruct (zlt (Int.zwordsize - y)); auto. replace Int.zwordsize with 32 in l by auto. lia.
  rewrite Z.mul_0_l, Z.add_0_r, Z.sub_sub_distr. lia.
  unfold Int.ltu. destruct (zlt (Int.unsigned sa) (Int.unsigned sa)); auto.
  lia.
Qed.

Theorem eval_cast8signed: unary_constructor_sound cast8signed (Val.sign_ext 8).
Proof.
  red; intros until x. unfold cast8signed. destruct (cast8signed_match a); intros.
  InvEval; TrivialExists.
  TrivialExists. simpl. rewrite mk_amount32_eq by auto.
  rewrite mk_amount32_eq by auto. unfold extr. rewrite Int.sub_zero_l.
  rewrite extr_sign_ext; auto. lia.
Qed.

Theorem eval_cast16signed: unary_constructor_sound cast16signed (Val.sign_ext 16).
Proof.
  red; intros until x. unfold cast16signed. destruct (cast16signed_match a); intros.
  InvEval; TrivialExists.
  TrivialExists. simpl. rewrite mk_amount32_eq by auto.
  rewrite mk_amount32_eq by auto. unfold extr. rewrite Int.sub_zero_l.
  rewrite extr_sign_ext; auto. lia.
Qed.

Theorem eval_cast16unsigned: unary_constructor_sound cast16unsigned (Val.zero_ext 16).
Proof.
  red; intros. unfold cast16unsigned.
  rewrite Val.zero_ext_and. apply eval_andimm; auto. lia.
Qed.



(** ** Floating-point conversions *)

Theorem eval_singleoffloat: unary_constructor_sound singleoffloat Val.singleoffloat.
Proof.
  red; intros; TrivialExists.
Qed.

Theorem eval_floatofsingle: unary_constructor_sound floatofsingle Val.floatofsingle.
Proof.
  red; intros; TrivialExists.
Qed.

Theorem eval_intoffloat:
  forall le a x y,
  eval_expr ge sp e m le a x ->
  Val.intoffloat x = Some y ->
  exists v, eval_expr ge sp e m le (intoffloat a) v /\ Val.lessdef y v.
Proof.
  intros; TrivialExists.
Qed.

Theorem eval_floatofint:
  forall le a x y,
  eval_expr ge sp e m le a x ->
  Val.floatofint x = Some y ->
  exists v, eval_expr ge sp e m le (floatofint a) v /\ Val.lessdef y v.
Proof.
  intros until y; unfold floatofint. case (floatofint_match a); intros; InvEval.
- TrivialExists.
- TrivialExists.
Qed.

Theorem eval_intuoffloat:
  forall le a x y,
  eval_expr ge sp e m le a x ->
  Val.intuoffloat x = Some y ->
  exists v, eval_expr ge sp e m le (intuoffloat a) v /\ Val.lessdef y v.
Proof.
  intros; TrivialExists.
Qed.

Theorem eval_floatofintu:
  forall le a x y,
  eval_expr ge sp e m le a x ->
  Val.floatofintu x = Some y ->
  exists v, eval_expr ge sp e m le (floatofintu a) v /\ Val.lessdef y v.
Proof.
  intros until y; unfold floatofintu. case (floatofintu_match a); intros; InvEval.
- TrivialExists.
- TrivialExists.
Qed.

Theorem eval_intofsingle:
  forall le a x y,
  eval_expr ge sp e m le a x ->
  Val.intofsingle x = Some y ->
  exists v, eval_expr ge sp e m le (intofsingle a) v /\ Val.lessdef y v.
Proof.
  intros; TrivialExists.
Qed.

Theorem eval_singleofint:
  forall le a x y,
  eval_expr ge sp e m le a x ->
  Val.singleofint x = Some y ->
  exists v, eval_expr ge sp e m le (singleofint a) v /\ Val.lessdef y v.
Proof.
  intros until y; unfold singleofint. case (singleofint_match a); intros; InvEval.
- TrivialExists.
- TrivialExists.
Qed.

Theorem eval_intuofsingle:
  forall le a x y,
  eval_expr ge sp e m le a x ->
  Val.intuofsingle x = Some y ->
  exists v, eval_expr ge sp e m le (intuofsingle a) v /\ Val.lessdef y v.
Proof.
  intros; TrivialExists.
Qed.

Theorem eval_singleofintu:
  forall le a x y,
  eval_expr ge sp e m le a x ->
  Val.singleofintu x = Some y ->
  exists v, eval_expr ge sp e m le (singleofintu a) v /\ Val.lessdef y v.
Proof.
  intros until y; unfold singleofintu. case (singleofintu_match a); intros; InvEval.
- TrivialExists.
- TrivialExists.
Qed.

(** Selection *)

Theorem eval_select:
  forall le ty cond al vl a1 v1 a2 v2 a b,
  select ty cond al a1 a2 = Some a ->
  eval_exprlist ge sp e m le al vl ->
  eval_expr ge sp e m le a1 v1 ->
  eval_expr ge sp e m le a2 v2 ->
  eval_condition cond vl m = Some b ->
  exists v,
     eval_expr ge sp e m le a v
  /\ Val.lessdef (Val.select (Some b) v1 v2 ty) v.
Proof.
  unfold select; intros.
  destruct (match ty with Tint | Tsingle => true | _ => false end); inv H.
  rewrite <- H3; TrivialExists.
Qed.

(** Addressing modes *)

Theorem eval_addressing:
  forall le chunk a v b ofs,
  eval_expr ge sp e m le a v ->
  v = Vptr b ofs ->
  match addressing chunk a with (mode, args) =>
    exists vl,
    eval_exprlist ge sp e m le args vl /\
    eval_addressing ge sp mode vl = Some v
  end.
Proof.
  intros until v. unfold addressing; case (addressing_match a); intros; InvEval.
  - exists (@nil val). split. eauto with evalexpr. simpl. auto.
  - exists (@nil val). split. eauto with evalexpr. simpl. auto.
  - exists (v1 :: nil). split. eauto with evalexpr. simpl. congruence.
  -  exists (v :: nil). split. eauto with evalexpr. subst v. simpl.
     rewrite Ptrofs.add_zero. auto.
Qed.

(** Builtins *)

Theorem eval_builtin_arg:
  forall a v,
  eval_expr ge sp e m nil a v ->
  CminorSel.eval_builtin_arg ge sp e m (builtin_arg a) v.
Proof.
  intros until v. unfold builtin_arg; case (builtin_arg_match a); intros; InvEval.
- constructor.
- constructor.
- constructor.
- simpl in H5. inv H5. constructor.
- subst v. constructor; auto.
- inv H. InvEval. simpl in H6; inv H6. constructor; auto.
- inv H. repeat constructor; auto.
- constructor; auto.
Qed.

(** Platform-specific known builtins *)

Theorem eval_platform_builtin:
  forall bf al a vl v le,
  platform_builtin bf al = Some a ->
  eval_exprlist ge sp e m le al vl ->
  platform_builtin_sem bf vl = Some v ->
  exists v', eval_expr ge sp e m le a v' /\ Val.lessdef v v'.
Proof.
  intros. discriminate.
Qed.

Theorem eval_platform_standard_builtin:
  forall bf al a vl v le,
  platform_standard_builtin bf al = Some a ->
  eval_exprlist ge sp e m le al vl ->
  standard_builtin_sem bf vl = Some v ->
  exists v', eval_expr ge sp e m le a v' /\ Val.lessdef v v'.
Proof.
  intros. discriminate.
Qed.

End CMCONSTR.
